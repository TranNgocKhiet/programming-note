<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AWS Lambda :: IT From Scratch</title>
    <link>//localhost:1313/note/05_cloud/aws/lambda/index.html</link>
    <description>With Dynamo and Cognito</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="//localhost:1313/note/05_cloud/aws/lambda/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Example with Dynamo and Cognito using Python</title>
      <link>//localhost:1313/note/05_cloud/aws/lambda/01_example_with_dynamo_and_cognito/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/note/05_cloud/aws/lambda/01_example_with_dynamo_and_cognito/index.html</guid>
      <description>import boto3 import json import os # Create client and handler dynamodb = boto3.resource(&#39;dynamodb&#39;) cognito_client = boto3.client(&#39;cognito-idp&#39;) # Get environment variables TABLE_NAME = os.environ.get(&#39;TABLE_NAME&#39;) USER_POOL_ID = os.environ.get(&#39;USER_POOL_ID&#39;) table = dynamodb.Table(TABLE_NAME) def build_update_params(updates): update_expression = &#34;SET &#34; expression_names = {} expression_values = {} # Use #name and #email to avoid reserved words attribute_map = { &#34;name&#34;: &#34;#name&#34;, &#34;email&#34;: &#34;#email&#34;, } for key, value in updates.items(): if key in attribute_map: placeholder = f&#34;:{key}&#34; attr_name = attribute_map[key] update_expression += f&#34;{attr_name} = {placeholder}, &#34; expression_values[placeholder] = value expression_names[attr_name] = key update_expression = update_expression.rstrip(&#34;, &#34;) return update_expression, expression_names, expression_values def lambda_handler(event, context): try: if &#34;body&#34; in event: body = json.loads(event[&#34;body&#34;]) else: body = event user_id = body.get(&#39;userId&#39;) updates = body.get(&#39;updates&#39;) if not user_id or not updates: return {&#39;statusCode&#39;: 400, &#39;body&#39;: &#39;Lỗi: Thiếu &#34;userId&#34; hoặc &#34;updates&#34;&#39;} update_expr, attr_names, attr_values = build_update_params(updates) if not attr_values: return {&#39;statusCode&#39;: 400, &#39;body&#39;: &#39;Không có trường hợp lệ nào để cập nhật&#39;} dynamo_response = table.update_item( Key={&#39;userId&#39;: user_id}, UpdateExpression=update_expr, ExpressionAttributeNames=attr_names, ExpressionAttributeValues=attr_values, ReturnValues=&#34;UPDATED_NEW&#34; ) if &#39;email&#39; in updates: new_email = updates[&#39;email&#39;] try: cognito_client.admin_update_user_attributes( UserPoolId=USER_POOL_ID, Username=user_id, UserAttributes=[ { &#39;Name&#39;: &#39;email&#39;, &#39;Value&#39;: new_email }, { &#39;Name&#39;: &#39;email_verified&#39;, &#39;Value&#39;: &#39;true&#39; } ] ) except Exception as e: print(f&#34;Cognito Error: {e}&#34;) return { &#39;statusCode&#39;: 500, &#39;body&#39;: f&#39;Update DynamoDB success, but failed to update Cognito: {str(e)}&#39; } success_body = { &#34;message&#34;: &#34;Update success&#34;, &#34;updatedAttributes&#34;: dynamo_response.get(&#39;Attributes&#39;) } return { &#39;statusCode&#39;: 200, &#39;body&#39;: json.dumps(success_body) } except Exception as e: print(f&#34;Unknow error: {e}&#34;) return { &#39;statusCode&#39;: 500, &#39;body&#39;: f&#39;Error when handle request: {str(e)}&#39; }&#xD;Declare and initialize&#xD;import boto3 import json import os dynamodb = boto3.resource(&#39;dynamodb&#39;) cognito_client = boto3.client(&#39;cognito-idp&#39;) TABLE_NAME = os.environ.get(&#39;TABLE_NAME&#39;) USER_POOL_ID = os.environ.get(&#39;USER_POOL_ID&#39;) table = dynamodb.Table(TABLE_NAME)&#xD;import boto3: Thư viện (SDK) chính thức của AWS cho Python, dùng để tương tác với các AWS Service import json: Dùng để xử lý dữ liệu JSON (ví dụ: event[&#34;body&#34;]) import os: Dùng để đọc các Environment variables trong Configuration của Lambda dynamodb = boto3.resource(&#39;dynamodb&#39;): Sử dụng giao diện “resource” (cấp cao, dễ dùng hơn) của boto3 cho DynamoDB cognito_client = boto3.client(&#39;cognito-idp&#39;): Sử dụng giao diện “client” (cấp thấp, chi tiết hơn) cho Cognito Identity Provider TABLE_NAME = os.environ.get(&#39;TABLE_NAME&#39;): Tên của bảng DynamoDB chứa thông tin người dùng USER_POOL_ID = os.environ.get(&#39;USER_POOL_ID&#39;): ID của Cognito User Pool nơi người dùng được quản lý table = dynamodb.Table(TABLE_NAME): Tạo một đối tượng Table cụ thể từ dynamodb resource, trỏ đến bảng có tên là TABLE_NAME. Điều này giúp thực hiện các thao tác (như update_item) trực tiếp trên bảng đó build_update_params Function&#xD;def build_update_params(updates):: Khai báo tên hàm, tên tham số update_expression = &#34;SET &#34;: Chuỗi lệnh SET cho DynamoDB (ví dụ: SET #name = :name, #email = :email) expression_names = {}: Một dictionary để map tên giữ chỗ (placeholder) với tên thuộc tính thật. Ví dụ: {&#34;#name&#34;: &#34;name&#34;}. Điều này rất quan trọng để tránh lỗi với các từ khóa dự trữ (reserved words) của DynamoDB (như name) expression_values = {}: Một dictionary để map tên giữ chỗ với giá trị thật. Ví dụ: {&#34;:name&#34;: &#34;John Doe&#34;}. Điều này giúp ngăn ngừa lỗi SQL injection (mặc dù đây là NoSQL, nguyên tắc tương tự) attribute_map = { &#34;name&#34;: &#34;#name&#34;, &#34;email&#34;: &#34;#email&#34;, }&#xD;Định nghĩa một attribute_map. Nó chỉ định rằng nếu updates có chứa “name” hoặc “email”, chúng ta sẽ sử dụng tên giữ chỗ là #name và #email trong UpdateExpression for key, value in updates.items(): if key in attribute_map: placeholder = f&#34;:{key}&#34; attr_name = attribute_map[key] update_expression += f&#34;{attr_name} = {placeholder}, &#34; expression_values[placeholder] = value expression_names[attr_name] = key&#xD;for key, value in updates.items():: Lặp qua từng cặp key (tên trường) và value (giá trị mới) trong dictionary updates mà người dùng gửi lên</description>
    </item>
  </channel>
</rss>