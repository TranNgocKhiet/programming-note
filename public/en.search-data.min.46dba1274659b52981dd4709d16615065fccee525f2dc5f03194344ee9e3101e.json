[{"id":0,"href":"/docs/note/programming-languages/python/01_data-structures/","title":"01_Data-structures","section":"Python","content":"Data Structures# NoneType# In Python, a value called None represents the absence of a value. The None value is the only value of the NoneType data type. (Other programming languages might call this value null, nil, or undefined). Just like the Boolean True and False values, you must always write None with a capital N. Input\nspam = print(\u0026#39;Hello!\u0026#39;) None == spamOuput\nTrue Sequence Data Types# The Python sequence data types include lists, strings, range objects returned by range(), and tuples. Mutable and Immutable Data types# A list value is a mutable data type: you can add, remove, or change its values; however, a string is immutable: it cannot be changed Input\nname = \u0026#39;Zophie a cat\u0026#39; name[7] = \u0026#39;the\u0026#39;Output\nTraceback (most recent call last):\rFile \u0026#34;\u0026lt;python-input-0\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\rname[7] = \u0026#39;the\u0026#39;\rTypeError: \u0026#39;str\u0026#39; object does not support item assignment The proper way to “mutate” a string is to use slicing and concatenation to build a new string by copying from parts of the old string print(new_name) Input\nname = \u0026#39;Zophie a cat\u0026#39; new_name = name[0:7] + \u0026#39;the\u0026#39; + name[8:12]Output\nZophie the cat "},{"id":1,"href":"/docs/note/operating-systems/linux/commands/","title":"Commands","section":"Linux","content":"Linux Commands# echo# Input\necho \u0026#34;Hello\u0026#34; Show User and Group Information | whoami and id# Input\nwhoamiOutput\nyourusernameInput\nidOutput\nuid=5000(labex) gid=5000(labex) groups=5000(labex),27(sudo),121(ssl-cert),5002(public) uid: Your User ID (a unique numerical identifier). gid: Your primary Group ID. groups: All the groups you are a member of. Input\nid rootOutput\nuid=0(root) gid=0(root) groups=0(root) root is the superuser – like the administrator of the system! Download the latest list of all available software and updates from the software servers | apt update# sudo: Super User DO, do something with aministrator permission apt: Application Manager Tool on systems like Ubuntu update: Synchronize app packages on your computer with Internaet Repositpories Input\nsudo apt update Interactive process viewer for Unix systems | htop# To install# htop is like Task Manager on Windows Input\nsudo apt install htopTo run# Input\nhtop Displays current location in the file system | pwd# pwd stands for \u0026ldquo;print working directory\u0026rdquo; Input\npwd Display relationship between the current directory and the home directory | echo ~# Input\necho ~` Show contents of current directory | ls# Input\nls Show contents of home directory | ls ~# Input\nls ~ Go to a folder | cd# Input\ncd foldername Go to an above folder | cd ..# Input\ncd .. Go to home directory | cd ~# Input\ncd ~ Create an empty file | touch# The touch command is used to create an empty file. If the file already exists, it updates the file\u0026rsquo;s timestamp without changing its content. It\u0026rsquo;s a simple way to create new, empty files. Input\ntouch file1.txt Write to a file | \u0026gt;# ```echo`` is a command that prints text. The \u0026gt; symbol redirects the output of echo into a file named file2.txt. If the file doesn\u0026rsquo;t exist, it\u0026rsquo;s created. If it does exist, its content is replaced. Input\necho \u0026#34;Hello, Linux\u0026#34; \u0026gt; file2.txt Create hidden file | .# This creates a hidden file. In Linux, any file or directory name that starts with a dot (.) is considered hidden. Input\necho \u0026#34;Hidden file\u0026#34; \u0026gt; .hiddenfile Create a directory | mkdir testdir# The mkdir command (short for \u0026ldquo;make directory\u0026rdquo;) creates a new directory named testdir Input\nmkdir testdir Detailed listing | ls -l# Input\nls -l Show hidden files | ls -a# Input\nls -a Combine options | ls -la# This combines the long format (-l) with showing all files (-a). Input\nls -la List contents of a specific directory | ls -l testdir# This lists the contents of the testdir directory Input\nls -l testdir # "},{"id":2,"href":"/docs/note/programming-languages/python/01_data-structures/01_list/","title":"List","section":"01_Data-structures","content":"List# Syntax# Input\nsquares = [x**2 for x in range(10)] print(squares)Output\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nInput\nproducts = [i * j for j in range(3) for i in range(3)] print(products)Output\n[0, 0, 0, 0, 1, 2, 0, 2, 4]\nInput\nwords = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] lengths = [len(word) for word in words] print(lengths)Output\n[5, 6, 6] Finding Index | index()# Input\nspam = [\u0026#39;hello\u0026#39;, \u0026#39;hi\u0026#39;, \u0026#39;howdy\u0026#39;, \u0026#39;heyas\u0026#39;] print(spam.index(\u0026#39;hello\u0026#39;))Output\n0\nInput\nspam = [\u0026#39;Zophie\u0026#39;, \u0026#39;Pooka\u0026#39;, \u0026#39;Fat-tail\u0026#39;, \u0026#39;Pooka\u0026#39;] print(spam.index(\u0026#39;Pooka\u0026#39;)) # When the list contains duplicates of the value, the method returns the index of its first appearanceOutput\n1 Adding Values | append()# Input\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;bat\u0026#39;] spam.append(\u0026#39;moose\u0026#39;) print(spam)Output\n[\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;moose\u0026#39;]\nInput\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;bat\u0026#39;] spam.insert(1, \u0026#39;chicken\u0026#39;) print(spam)Output\n[\u0026#39;cat\u0026#39;, \u0026#39;chicken\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;bat\u0026#39;] Removing Values | remove()# Input\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;] spam.remove(\u0026#39;bat\u0026#39;) print(spam)Output\n[\u0026#39;cat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;] If the value appears multiple times in the list, the method will remove only the first instance of it Input\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;hat\u0026#39;, \u0026#39;cat\u0026#39;] spam.remove(\u0026#39;cat\u0026#39;) print(spam)Output\n[\u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;hat\u0026#39;, \u0026#39;cat\u0026#39;] Pop Values | pop()# Input\nmy_list = [1, 2, 3, 4, 5] popped_element = my_list.pop() print(popped_element) print(my_list)Output\n5\r[1, 2, 3, 4] Sorting Values | sort()# Input\nspam = [2, 5, 3.14, 1, -7] spam.sort() print(spam) spam = [\u0026#39;Ants\u0026#39;, \u0026#39;Cats\u0026#39;, \u0026#39;Dogs\u0026#39;, \u0026#39;Badgers\u0026#39;, \u0026#39;Elephants\u0026#39;] spam.sort() print(spam)Output\n[-7, 1, 2, 3.14, 5]\r[\u0026#39;Ants\u0026#39;, \u0026#39;Badgers\u0026#39;, \u0026#39;Cats\u0026#39;, \u0026#39;Dogs\u0026#39;, \u0026#39;Elephants\u0026#39;]\nInput\nspam = [\u0026#39;Ants\u0026#39;, \u0026#39;Cats\u0026#39;, \u0026#39;Dogs\u0026#39;, \u0026#39;Badgers\u0026#39;, \u0026#39;Elephants\u0026#39;] spam.sort(reverse=True) print(spam)Output\n[\u0026#39;Elephants\u0026#39;, \u0026#39;Dogs\u0026#39;, \u0026#39;Cats\u0026#39;, \u0026#39;Badgers\u0026#39;, \u0026#39;Ants\u0026#39;] sort() uses ASCIIbetical order rather than actual alphabetical order for sorting strings, this means uppercase letters come before lowercase letters, placing the lowercase a after the uppercase Z Input\nspam = [\u0026#39;Alice\u0026#39;, \u0026#39;ants\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;badgers\u0026#39;, \u0026#39;Carol\u0026#39;, \u0026#39;cats\u0026#39;] spam.sort() print(spam)Output\n[\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Carol\u0026#39;, \u0026#39;ants\u0026#39;, \u0026#39;badgers\u0026#39;, \u0026#39;cats\u0026#39;] Can’t sort lists that have both number values and string values in them, as Python doesn’t know how to compare these values Input\nspam = [1, 3, 2, 4, \u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;] spam.sort() print(spam)Output\nTraceback (most recent call last):\rFile \u0026#34;\u0026lt;python-input-0\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\rspam.sort()\rTypeError: \u0026#39;\u0026lt;\u0026#39; not supported between instances of \u0026#39;str\u0026#39; and \u0026#39;int\u0026#39;\nInput\nspam = [\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39;] spam.sort(key=str.lower) print(spam)Output\n[\u0026#39;a\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;Z\u0026#39;] Reversing Values | reverse()# Input\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;moose\u0026#39;] spam.reverse() print(spam)Output\n[\u0026#39;moose\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;] List Item Enumeration | enumerate()# Input\nsupplies = [\u0026#39;pens\u0026#39;, \u0026#39;staplers\u0026#39;, \u0026#39;flamethrowers\u0026#39;, \u0026#39;binders\u0026#39;] for index, item in enumerate(supplies): print(\u0026#39;Index \u0026#39; + str(index) + \u0026#39; in supplies is: \u0026#39; + item)Output\nIndex 0 in supplies is: pens\rIndex 1 in supplies is: staplers\rIndex 2 in supplies is: flamethrowers\rIndex 3 in supplies is: binders Negative Indexes# Input\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;] print(\u0026#39;The \u0026#39; + spam[-1] + \u0026#39; is afraid of the \u0026#39; + spam[-3] + \u0026#39;.\u0026#39;)Output\nThe elephant is afraid of the bat. Slices# Input\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1])Output\n[\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;]\r[\u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;]\r[\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;]\nInput\nspam = [\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;] print(spam[:2]) print(spam[1:]) print(spam[:])Output\n[\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;]\r[\u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;]\r[\u0026#39;cat\u0026#39;, \u0026#39;bat\u0026#39;, \u0026#39;rat\u0026#39;, \u0026#39;elephant\u0026#39;] The Multiple Assignment Trick# Input\ncat = [\u0026#39;fat\u0026#39;, \u0026#39;gray\u0026#39;, \u0026#39;loud\u0026#39;] size, color, disposition = cat print(size, color, disposition)Output\nfat gray loud "},{"id":3,"href":"/docs/note/programming-languages/python/","title":"Python","section":"Programming-Languages","content":"Source preferences# Books# Automate the Boring Stuff with Python by Al Sweigart\nCourses# Python Mastery: The Complete Web Programming Course by Knowledge Nest in Udemy\n"},{"id":4,"href":"/docs/note/virtual-machines/virtual-box/","title":"Virtual-Box","section":"Virtual-Machines","content":"Virtual Box# Link download# https://www.virtualbox.org/wiki/Downloads\nVideo reference# https://www.youtube.com/watch?v=lmeDvSgN6zY\n"},{"id":5,"href":"/docs/note/programming-languages/python/02_operators/","title":"02_Operators","section":"Python","content":"Operators# Comparison Operator# Input\n42 == 42Output\nTrue\nInput\n42 == 42.0Output\nTrue The expression 42 == \u0026lsquo;42\u0026rsquo; evaluates to False because Python considers the integer 42 to be different from the string \u0026lsquo;42\u0026rsquo;. However, Python does consider the integer 42 to be the same as the float 42.0. Input\n42 == \u0026#39;42\u0026#39;Output\nFalse The in and not in Operators# Input\nprint(\u0026#39;howdy\u0026#39; in [\u0026#39;hello\u0026#39;, \u0026#39;hi\u0026#39;, \u0026#39;howdy\u0026#39;, \u0026#39;heyas\u0026#39;]) spam = [\u0026#39;hello\u0026#39;, \u0026#39;hi\u0026#39;, \u0026#39;howdy\u0026#39;, \u0026#39;heyas\u0026#39;] print(\u0026#39;cat\u0026#39; in spam) print(\u0026#39;howdy\u0026#39; not in spam) print(\u0026#39;cat\u0026#39; not in spam)Output\nTrue\rFalse\rFalse\rTrue "},{"id":6,"href":"/docs/note/programming-languages/python/01_data-structures/02_tuple/","title":"Tuple","section":"01_Data-structures","content":"Tuple# Syntax# Input\na, b, c = (10, 20, 30) print(a) print(b) print(c)Output\n10\r20\r30 Multiple data type values# Input\nmixed_tuple = (1, \u0026#39;hello\u0026#39; , 3.14) print(mixed_tuple) print(type(mixed_tuple[0])) print(type(mixed_tuple[1])) print(type(mixed_tuple[2]))Output\n(1, \u0026#39;hello\u0026#39;, 3.14)\r\u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\r\u0026lt;class \u0026#39;str\u0026#39;\u0026gt;\r\u0026lt;class \u0026#39;float\u0026#39;\u0026gt;\nInput\neggs = (\u0026#39;hello\u0026#39;, 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs))Output\nhello\r(42, 0.5)\r3 Immutable# Input\neggs = (\u0026#39;hello\u0026#39;, 42, 0.5) eggs[1] = 99 Output\nFile \u0026#34;\u0026lt;python-input-0\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\reggs[1] = 99\rTypeError: \u0026#39;tuple\u0026#39; object does not support item assignment "},{"id":7,"href":"/docs/note/programming-languages/python/03_statements/","title":"03_Statements","section":"Python","content":"Statements# The global Statement# If you need to modify a global variable from within a function, use the global statement. Including a line such as global eggs at the top of a function tells Python, “In this function, eggs refers to the global variable, so don’t create a local variable with this name. Input\ndef spam(): global eggs eggs = \u0026#39;spam\u0026#39; eggs = \u0026#39;global\u0026#39; spam() print(eggs)Output\nspam "},{"id":8,"href":"/docs/note/programming-languages/python/01_data-structures/03_dictionary/","title":"Dictionary","section":"01_Data-structures","content":"Dictionary# Syntax# Input\nmy_cat = {\u0026#39;size\u0026#39;: \u0026#39;fat\u0026#39;, \u0026#39;color\u0026#39;: \u0026#39;gray\u0026#39;, \u0026#39;age\u0026#39;: 17} print(my_cat[\u0026#39;size\u0026#39;]) print(\u0026#39;My cat has \u0026#39; + my_cat[\u0026#39;color\u0026#39;] + \u0026#39; fur.\u0026#39;)Output\nfat\rMy cat has gray fur\nInput\nspam = {12345: \u0026#39;Luggage Combination\u0026#39;, 42: \u0026#39;The Answer\u0026#39;} print(spam[12345]) print(spam[42]) print(spam[0])Output\nLuggage Combination\rThe Answer\rTraceback (most recent call last):\rFile \u0026#34;\u0026lt;python-input-0\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\rKeyError: 0 Returning Values | values()# Input\nspam = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;age\u0026#39;: 42} for v in spam.values(): print(v)Output\nred\r42 Returning Keys | keys()# Input\nspam = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;age\u0026#39;: 42} for k in spam.keys(): print(k)Output\ncolor\rage Returning Keys and Values | items()# Input\nspam = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;age\u0026#39;: 42} for i in spam.items(): print(i)Output\n(\u0026#39;color\u0026#39;, \u0026#39;red\u0026#39;)\r(\u0026#39;age\u0026#39;, 42) Checking Whether a Key Exists | get()# Dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key doesn’t exis Input\npicnic_items = {\u0026#39;apples\u0026#39;: 5, \u0026#39;cups\u0026#39;: 2} print(\u0026#39;I am bringing \u0026#39; + str(picnic_items.get(\u0026#39;cups\u0026#39;, 0)) + \u0026#39; cups.\u0026#39;) print(\u0026#39;I am bringing \u0026#39; + str(picnic_items.get(\u0026#39;eggs\u0026#39;, 0)) + \u0026#39; eggs.\u0026#39;)Output\nI am bringing 2 cups.\rI am bringing 0 eggs. Setting Default Values | setdefault()# The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key doesn’t exist; if the key does exist, the setdefault() method returns the key’s value Input\nspam = {\u0026#39;name\u0026#39;: \u0026#39;Pooka\u0026#39;, \u0026#39;age\u0026#39;: 5} print(spam.setdefault(\u0026#39;color\u0026#39;, \u0026#39;black\u0026#39;)) # Sets \u0026#39;color\u0026#39; key to \u0026#39;black\u0026#39; print(spam.setdefault(\u0026#39;color\u0026#39;, \u0026#39;white\u0026#39;)) # Does nothingOutput\nblack\rblackView object# Input\nspam = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;age\u0026#39;: 42} print(spam.keys()) print(list(spam.keys()))Output\ndict_keys([\u0026#39;color\u0026#39;, \u0026#39;age\u0026#39;])\r[\u0026#39;color\u0026#39;, \u0026#39;age\u0026#39;] The Multiple Assignment Trick# Input\nspam = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;age\u0026#39;: 42} for k, v in spam.items(): print(\u0026#39;Key: \u0026#39; + str(k) + \u0026#39; Value: \u0026#39; + str(v))Output\nKey: color Value: red\rKey: age Value: 42 "},{"id":9,"href":"/docs/note/programming-languages/python/04_functions/","title":"04_Functions","section":"Python","content":"Functions# The round() Function# For halfway numbers that end with .5, the number is rounded to the nearest even integer. This is called banker’s rounding. Input\nround(3.5)Output\n4\nInput\nround(2.5)Output\n2 The bool() Function# When used in conditions, 0, 0.0, and \u0026rsquo;\u0026rsquo; (the empty string) are considered False, while all other values are considered True. The print() Function# Input\ndef greet(name=\u0026#34;Guest\u0026#34;): print(f\u0026#39;Hello, {name}!\u0026#39;) greet() greet(\u0026#34;Bob\u0026#34;)Output\nHello, Guest!\rHello, Bob! Named Parameters# Input\nprint(\u0026#39;Hello\u0026#39;) print(\u0026#39;World\u0026#39;)Output\nHello\rWorld\nInput\nprint(\u0026#39;Hello\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;World\u0026#39;)Output\nHelloWorld\nInput\nprint(\u0026#39;cats\u0026#39;, \u0026#39;dogs\u0026#39;, \u0026#39;mice\u0026#39;)Output\ncats dogs mice\nInput\nprint(\u0026#39;cats\u0026#39;, \u0026#39;dogs\u0026#39;, \u0026#39;mice\u0026#39;, sep=\u0026#39;,\u0026#39;)Output\ncats,dogs,mice The Multiple Assignment Trick# Input\ndef get_person_information(): name = \u0026#39;Alice\u0026#39; age = 30 city = \u0026#39;New York\u0026#39; return name, age, city name, age, city = get_person_information() print(f\u0026#39;Name: {name}, Age: {age}, City: {city}\u0026#39;)Output\nName: Alice, Age: 30, City: New York Anonymous Function# Input\ndouble = lambda x: x * 2 print(double(5))Output\n10\nInput\ndata = [(1,5), (3,2), (2,7)] sorted_data = sorted(data, key = lambda x: x[1]) # Sort by second value in tuples print(sorted_data)Output\n[(3, 2), (1, 5), (2, 7)]\nInput\nnumbers = [1, 2, 3, 4, 5, 6] even_number = list(filter(lambda x: x % 2 == 0, numbers)) print(even_number)Output\n[2, 4, 6] Generator and yield# Input\ndef simple_generator(): yield 1 yield 2 yield 3 gen = simple_generator() for value in gen: print(value)Output\n1\r2\r3 Function and class decorators# Input\nimport time def timing_decorator(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(f\u0026#34;Function {func.__name__} executed in {end_time - start_time:.4f}s\u0026#34;) return result return wrapper @timing_decorator def slow_function(): time.sleep(2) return \u0026#34;Function complete\u0026#34; print(slow_function())Input\ndef add_method_decorator(cls): def new_method(self): return \u0026#34;This is a new method\u0026#34; cls.new_method = new_method return cls @add_method_decorator class MyClass: def existing_method(self): return \u0026#34;This is an existing method\u0026#34; obj = MyClass() print(obj.existing_method()) print(obj.new_method()) Context manager# Những hàm có dạng __name__ được gọi là Phương thức Dunder (Dunder Methods) hoặc Phương thức Ma thuật (Magic Methods). \u0026ldquo;Dunder\u0026rdquo; là viết tắt của \u0026ldquo;Double Underscore\u0026rdquo; (hai dấu gạch dưới).\nĐây là một phương thức đặc biệt mà Python sẽ tự động gọi trong một hoàn cảnh cụ thể. Bạn (lập trình viên) không nên gọi trực tiếp các hàm này.\nVí dụ đơn giản:\nKhi bạn viết a + b, Python sẽ bí mật gọi a.add(b). Khi bạn viết len(my_list), Python sẽ bí mật gọi my_list.len(). Khi bạn viết with \u0026hellip; as f:, Python sẽ bí mật gọi f.enter(). Khi bạn viết obj = MyClass(), Python sẽ bí mật gọi obj.init() (sau khi đã gọi new). Input\nclass MyContextManager: def __enter__(self): print(\u0026#34;Entering the context\u0026#34;) return self def __exit__(self, exc_type, exc_val, exc_tb): print(\u0026#34;Existing the context\u0026#34;) def do_something(self): print(\u0026#34;Doing something\u0026#34;) with MyContextManager() as manager: manager.do_something() "},{"id":10,"href":"/docs/note/programming-languages/python/01_data-structures/04_string/","title":"String","section":"01_Data-structures","content":"String# String is like a list of characters, so is inherits list attributes Escape Characters | \\# Input\nprint(\u0026#39;Say hi to Bob\\\u0026#39;s mother.\u0026#39;)Output\nSay hi to Bob\u0026#39;s mother. Raw Strings | r# Input\nprint(r\u0026#39;The file is in C:\\Users\\Alice\\Desktop\u0026#39;)Output\nThe file is in C:\\Users\\Alice\\Desktop Multiline Strings | ''' '''# Input\nprint(\u0026#39;\u0026#39;\u0026#39;Dear Alice, Can you feed Eve\u0026#39;s cat this weekend? Sincerely, Bob\u0026#39;\u0026#39;\u0026#39;)Output\nDear Alice,\rCan you feed Eve\u0026#39;s cat this weekend?\rSincerely,\rBob Multiline Comments | \u0026quot;\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;\u0026quot;# Input\n\u0026#34;\u0026#34;\u0026#34;This is a test Python program. Written by Al Sweigart al@inventwithpython.com This program was designed for Python 3, not Python 2. \u0026#34;\u0026#34;\u0026#34; def say_hello(): \u0026#34;\u0026#34;\u0026#34;This function prints hello. It does not return anything.\u0026#34;\u0026#34;\u0026#34; print(\u0026#39;Hello!\u0026#39;) F-Strings | f# Input\nname = \u0026#39;Al\u0026#39; age = 4000 print(f\u0026#39;My name is {name}. I am {age} years old.\u0026#39;) print(f\u0026#39;In ten years I will be {age + 10}\u0026#39;)Output\nMy name is Al. I am 4000 years old.\rIn ten years I will be 4010 F-String Alternatives | %s and format()# Input\nname = \u0026#39;Al\u0026#39; age = 4000 print(\u0026#39;My name is %s. I am %s years old.\u0026#39; % (name, age)) print(\u0026#39;In ten years I will be %s\u0026#39; % (age + 10))Output\nMy name is Al. I am 4000 years old.\rIn ten years I will be 4010\nInput\nname = \u0026#39;Al\u0026#39; age = 4000 print(\u0026#39;My name is {}. I am {} years old.\u0026#39;.format(name, age))Output\nMy name is Al. I am 4000 years old. You can put the index integer (starting at 0) inside the curly brackets to note which of the arguments to format() should be inserted Input\nname = \u0026#39;Al\u0026#39; age = 4000 print(\u0026#39;{1} years ago, {0} was born and named {0}.\u0026#39;.format(name, age))Output\n4000 years ago, Al was born and named Al. Changing the Case | upper() and lower()# Input\nspam = \u0026#39;Hello, world!\u0026#39; spam = spam.upper() print(spam) spam = spam.lower() print(spam)Output\nHELLO, WORLD!\rhello, world! Checking the Case | isupper() and ```islower()``# Input\nspam = \u0026#39;Hello, world!\u0026#39; print(spam.islower()) print(spam.isupper()) print(\u0026#39;HELLO\u0026#39;.isupper()) print(\u0026#39;abc12345\u0026#39;.islower()) print(\u0026#39;12345\u0026#39;.islower()) print(\u0026#39;12345\u0026#39;.isupper())Output\nFalse\rFalse\rTrue\rTrue\rFalse\rFalse Checking String Characteristics | isalpha(), isalnum(), isdecimal(), isspace() and istitle()# Input\nprint(\u0026#39;hello\u0026#39;.isalpha()) print(\u0026#39;hello123\u0026#39;.isalpha()) print(\u0026#39;hello123\u0026#39;.isalnum()) print(\u0026#39;hello\u0026#39;.isalnum()) print(\u0026#39;123\u0026#39;.isdecimal()) print(\u0026#39; \u0026#39;.isspace()) print(\u0026#39;This Is Title Case\u0026#39;.istitle())Output\nTrue\rFalse\rTrue\rTrue\rTrue\rTrue\rTrue Checking the Start or End of a String | startswith() and endswith()# Input\nprint(\u0026#39;Hello, world!\u0026#39;.startswith(\u0026#39;Hello\u0026#39;)) print(\u0026#39;Hello, world!\u0026#39;.endswith(\u0026#39;world!\u0026#39;)) print(\u0026#39;abc123\u0026#39;.startswith(\u0026#39;abcdef\u0026#39;)) print(\u0026#39;abc123\u0026#39;.endswith(\u0026#39;12\u0026#39;)) print(\u0026#39;Hello, world!\u0026#39;.startswith(\u0026#39;Hello, world!\u0026#39;)) print(\u0026#39;Hello, world!\u0026#39;.endswith(\u0026#39;Hello, world!\u0026#39;))Output\nTrue\rTrue\rFalse\rFalse\rTrue\rTrue Joining Strings | join()# Input\nprint(\u0026#39;, \u0026#39;.join([\u0026#39;cats\u0026#39;, \u0026#39;rats\u0026#39;, \u0026#39;bats\u0026#39;]))Output\ncats, rats, bats Splitting Strings | split()# Input\nprint(\u0026#39;My name is Simon\u0026#39;.split()) print(\u0026#39;My name is Simon\u0026#39;.split(\u0026#39;m\u0026#39;))Output\n[\u0026#39;My\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;Simon\u0026#39;]\r[\u0026#39;My na\u0026#39;, \u0026#39;e is Si\u0026#39;, \u0026#39;on\u0026#39;] Justifying Text | rjust and ljust# Input\nprint(\u0026#39;Hello\u0026#39;.rjust(10)) print(\u0026#39;Hello\u0026#39;.rjust(20)) print(\u0026#39;Hello, World\u0026#39;.rjust(20)) print(\u0026#39;Hello\u0026#39;.ljust(10)) Output\nHello\rHello\rHello, World\rHello Input\nprint(\u0026#39;Hello\u0026#39;.rjust(20, \u0026#39;*\u0026#39;)) print(\u0026#39;Hello\u0026#39;.ljust(20, \u0026#39;-\u0026#39;))Output\n***************Hello\rHello--------------- Centering Text | center()# Input\nprint(\u0026#39;Hello\u0026#39;.center(20)) print(\u0026#39;Hello\u0026#39;.center(20, \u0026#39;=\u0026#39;))Output\nHello =======Hello======== Removing Whitespace | strip(), lstrip() and rstrip()# Input\nspam = \u0026#39; Hello, World \u0026#39; print(spam.strip()) print(spam.lstrip()) print(spam.rstrip()) spam = \u0026#39;SpamSpamBaconSpamEggsSpamSpam\u0026#39; # A string argument will specify which characters on the ends to strip print(spam.strip(\u0026#39;ampS\u0026#39;)) print(spam.strip(\u0026#39;Spam\u0026#39;)) Output\nHello, World\rHello, World Hello, World\rBaconSpamEggs\rBaconSpamEggs Numeric Code Points of Characters | ord() and chr()# Input\nprint(ord(\u0026#39;A\u0026#39;)) print(ord(\u0026#39;4\u0026#39;)) print(ord(\u0026#39;!\u0026#39;)) print(chr(65)) print(ord(\u0026#39;A\u0026#39;) \u0026lt; ord(\u0026#39;B\u0026#39;)) print(chr(ord(\u0026#39;A\u0026#39;) + 1))Output\n65\r52\r33\rA\rTrue\rB "},{"id":11,"href":"/docs/note/programming-languages/python/05_parameters/","title":"05_Parameters","section":"Python","content":"Parameters# *args# Đây là một hàm đơn giản, nhận vào hai tham số và trả về tổng của chúng: Input\ndef foo(x, y): return x + y print(foo(1, 2))Output\n3 Bây giờ, vấn đề của chúng ta là cần tính tổng của tất cả các số được truyền vào hàm, nhưng không biết trước số lượng của chúng. Đây là lúc là cú pháp *args cực kỳ hữu ích, bởi nó cũng giúp chúng ta có thể truyền một số lượng tham số tuỳ ý vào hàm. Input\ndef foo(*args): result = 0 for x in args: result += x return result print(foo(1, 2)) print(foo(1, 2, 3))Output\n3 6 Về lý thuyết, chúng ta có thể đặt *args ở bất cứ đâu chúng ta muốn trong định nghĩa hàm. Tuy nhiên, nếu đặt ở giữa, chúng ta sẽ không thể gọi hàm được bởi mọi lời gọi sẽ đều gặp lỗi. Nguyên nhân là do *args sẽ nhận toàn bộ các tham số \u0026ldquo;còn lại\u0026rdquo; sau khi các tham số đầu tiên đã có giá trị, do đó, các tham số phía sau *args sẽ không bao giờ được truyền vào nữa. **kwargs# Cách sử dụng **kwargs cũng tương tự như như *args, tuy nhiên, nó không dùng cho các tham số thông thường truyền vào lần lượt, mà nó được sử dụng cho các tham số đặt tên (thuật ngữ chính xác là named arguments hoặc keyword arguments). def foo(a=0, b=1): return a + b print(foo()) print(foo(1, 2)) print(foo(b=3, a=4))Output\n1\r3\r7\nInput\ndef foo(**kwargs): for key, value in kwargs.items(): print(key, value) print(foo(a=1, b=2))Output\na 1\rb 2 Lưu ý rằng, với cách sử dụng **kwargs thì kwargs trong hàm sẽ nhận giá trị là một dict với key là các tham số được truyền kèm giá trị tương ứng của chúng. Notice for *args and ```**kwargs``# Thứ tự khi khai báo các tham số này rất quan trọng và không thể thay đổi được. Thứ tự đúng sẽ là: Các tham số bình thường *args **kwargs Upack with * and **# When calling function# Cú pháp * và ** khi gọi hàm sẽ yêu cầu unpack giá trị được truyền vào trước khi thực hiện hàm đó. Và khi unpack, hàm sẽ nhận các tham số đơn lẻ như các tham số riêng biệt vậy.\nChúng ta có thể sử dụng unpack để truyền tham số vào cho hàm. Nói một cách đơn giản thì cú pháp * được xử dụng với một đối tượng iterable, còn ** chỉ có thể dùng được với dict mà thôi.\nInput\ndef foo(**kargs): for data in kargs.items(): print(data, end=\u0026#39;\u0026#39;) print() x = (1, 2, 3) y = {\u0026#39;a\u0026#39;: 7, \u0026#39;b\u0026#39;: 8, \u0026#39;c\u0026#39;: 9} print(x) print(*x) foo(**y)Output\n(1, 2, 3)\r1 2 3\r(\u0026#39;a\u0026#39;, 7)(\u0026#39;b\u0026#39;, 8)(\u0026#39;c\u0026#39;, 9) When define variables# Một nhu cầu khá thường xuyên của lập trình viên đó là chia giá trị một list (hoặc tuple) vào các biến riêng biệt. Input\nx = [1, 2, 3, 4, 5, 6] a, *b, c = x print(a) print(b) print(c)Output\n1\r[2, 3, 4, 5]\r6 Một vấn đề nho nhỏ là cú pháp ** không áp dụng được khi gán biến để unpack một dict được. Other cases# Một điều thú vị là unpack có thể áp dụng với mọi đối tượng iterable, nó sẽ rất cần thiết nếu chúng ta cần làm \u0026ldquo;phẳng\u0026rdquo; 2 hay nhiều list. list1 = [1, 2, 3] list2 = [4, 5] list3 = [6, 7, 8, 9] print([*list1, *list2, *list3])Output\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nInput\ndict1 = {\u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2} dict2 = {\u0026#34;C\u0026#34;: 3, \u0026#34;D\u0026#34;: 4} print({**dict1, **dict2})Output\n{\u0026#39;A\u0026#39;: 1, \u0026#39;B\u0026#39;: 2, \u0026#39;C\u0026#39;: 3, \u0026#39;D\u0026#39;: 4} "},{"id":12,"href":"/docs/note/programming-languages/python/01_data-structures/05_set/","title":"Set","section":"01_Data-structures","content":"Set# Syntax# Input\nmy_set = {1, 2, 3} print(my_set)Output\n{1, 2, 3} Add Values | add()# Data in set cannot be duplicated Input\nmy_set = {1, 2, 3} my_set.add(4) my_set.add(2) print(my_set)Output\n{1, 2, 3, 4} Remove Values | remove()# Data in set cannot be duplicated Input\nmy_set = {1, 2, 3, 4} my_set.remove(4) print(my_set) try: my_set.remove(5) except KeyError as e: print(\u0026#39;Error: \u0026#39;, e) print(my_set)Output\n{1, 2, 3}\r{1, 2, 3} Discard Values | discard()# Input\nmy_set = {1, 2, 3, 4} my_set.discard(4) print(my_set) my_set.discard(5) print(my_set)Output\n{1, 2, 3}\r{1, 2, 3} Set Union | union()# Input\nset1 = {1, 2, 3} set2 = {4, 5, 6} union_set = set1.union(set2) print(union_set)Output\n{1, 2, 3, 4, 5, 6} Set Intersection | intersection()# Input\nset1 = {1, 2, 3} set2 = {3, 4, 5} intersection_set = set1.intersection(set2) print(intersection_set)Output\n{3} "},{"id":13,"href":"/docs/note/programming-languages/python/06_classes/","title":"06_Classes","section":"Python","content":"Classes# Syntax# Input\nclass Car: def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.is_running = False def start(self): self.is_running = True print(\u0026#34;Car started.\u0026#34;) def drive(self): if self.is_running: print(\u0026#34;Car is moving.\u0026#34;) else: print(\u0026#34;Car is not started yet.\u0026#34;) my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;, 2022) print(\u0026#39;My car: \u0026#39;, my_car.make, my_car.model, my_car.year) my_car.start() my_car.drive()Output\nMy car: Toyota Corolla 2022\rCar started.\rCar is moving. Inheritance# Input\nclass Animal: def speak(self): print(\u0026#34;Animal speaks\u0026#34;) class Dog(Animal): def bark(self): print(\u0026#34;Dog barks\u0026#34;) def wag_tail(self): print(\u0026#34;Dog wags tail\u0026#34;) dog = Dog() dog.speak() dog.bark()Output\nAnimal speaks\rDog barks "},{"id":14,"href":"/docs/note/programming-languages/python/01_data-structures/06_comparision/","title":"Comparision","section":"01_Data-structures","content":"Comparision# List and Tuple Type Conversion# Input\nprint(tuple([\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, 5])) print(list((\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, 5))) print(list(\u0026#39;hello\u0026#39;))Output\n(\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, 5)\r[\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, 5]\r[\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] Comparing Dictionarie and List# Input\nspam = [\u0026#39;cats\u0026#39;, \u0026#39;dogs\u0026#39;, \u0026#39;moose\u0026#39;] bacon = [\u0026#39;dogs\u0026#39;, \u0026#39;moose\u0026#39;, \u0026#39;cats\u0026#39;] print(spam == bacon) # The order of list items mattersOuput\nFalse\nInput\neggs = {\u0026#39;name\u0026#39;: \u0026#39;Zophie\u0026#39;, \u0026#39;species\u0026#39;: \u0026#39;cat\u0026#39;, \u0026#39;age\u0026#39;: \u0026#39;8\u0026#39;} ham = {\u0026#39;species\u0026#39;: \u0026#39; t\u0026#39;, \u0026#39;age\u0026#39;: \u0026#39;8\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Zophie\u0026#39;} print(eggs == ham) The order of dictionary key-value pairs doesn\u0026#39;t matterOutput\nTrue "},{"id":15,"href":"/docs/note/programming-languages/python/07_files/","title":"07_Files","section":"Python","content":"Files# Read and write# Input\nwith open(\u0026#39;example.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: file.write(\u0026#39;Hello, world!\\n\u0026#39;) file.write(\u0026#39;This is a test file\\n\u0026#39;) with open(\u0026#39;example.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: content = file.read() print(content) with open(\u0026#39;example.txt\u0026#39;, \u0026#39;a\u0026#39;) as file: file.write(\u0026#39;\\nAppending a new line.\u0026#39;) with open(\u0026#39;example.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: for line in file: print(line, end=\u0026#39;\u0026#39;)Output\nHello, world!\rThis is a test file\rHello, world!\rThis is a test file\rAppending a new line. Read line# Input\nwith open(\u0026#39;example.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: file.write(\u0026#39;Line 1\\nLine 2\\nLine 3\u0026#39;) with open(\u0026#39;example.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: content = file.read() print(content) with open(\u0026#39;example.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: line1 = file.readline() line2 = file.readline() print(\u0026#39;\\n\u0026#39;, line1, line2)Output\nLine 1\rLine 2\rLine 3\rLine 1\rLine 2 Write lines# Input\nwith open(\u0026#39;example.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: file.write(\u0026#39;Single line using write()\\n\u0026#39;) lines = [\u0026#39;line 1\\n\u0026#39;, \u0026#39;line 2\\n\u0026#39;, \u0026#39;line 3\\n\u0026#39;] with open(\u0026#39;example.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: file.writelines(lines) with open(\u0026#39;example.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: content = file.read() print(\u0026#34;Using writelines():\\n\u0026#34;, content)Output\nUsing writelines():\rline 1\rline 2\rline 3 "},{"id":16,"href":"/docs/note/programming-languages/python/08_libraries/","title":"08_Libraries","section":"Python","content":"Libraries# Ensure you are in the Python 3 mode in the Mu editor. The current mode is displayed in the bottom right corner of the window. Click the Admin or cog icon (gear icon) in the bottom right corner of the Mu editor. In the window that appears, select the Third Party Packages tab. Type name of the libraries into the text box. You can install multiple packages by placing each on a new line. Click OK. math# Input\nimport math result = math.sqrt(16) print(result)Output\n4.0\nInput\nfrom math import pi, cos result = cos(pi) print(result)Output\n-1.0 numpy# Input\nimport numpy as np array1 = np.array([1, 2, 3, 4, 5]) array2 = np.array([[1, 2, 3], [4, 5, 6]]) array3 = np.array([1, 2, 3]) array4 = np.array([4, 5, 6]) addition = array3 + array4 multiplication = array3 * array4 print(array1) print(array2) print(addition) print(multiplication)Output\n[1 2 3 4 5]\r[[1 2 3]\r[4 5 6]]\r[5 7 9]\r[ 4 10 18] datetime# Input\nimport datetime now = datetime.datetime.today() print(now)Output\n2025-11-04 20:03:37.981197 random# Input\nimport random rand_int = random.randint(1, 10) rand_float = random.random() print(rand_int) print(rand_float)Output\n6\r0.8069049490320905 os# Input\nimport os files = os.listdir(\u0026#39;.\u0026#39;) print(files)Output\n[\u0026#39;chapter6_coinFlipStreaks.py\u0026#39;, \u0026#39;chapter6_commaCode.py\u0026#39;, \u0026#39;collatz.py\u0026#39;, \u0026#39;dishonestcapacity.py\u0026#39;, \u0026#39;exitExample.py\u0026#39;, \u0026#39;exm.py\u0026#39;, \u0026#39;hello.py\u0026#39;, \u0026#39;isValidChesSBoard.py\u0026#39;, \u0026#39;matrixscreensaver.py\u0026#39;, \u0026#39;printTable.py\u0026#39;, \u0026#39;rpsGame.py\u0026#39;, \u0026#39;rpsGame_myVersion.py\u0026#39;, \u0026#39;yourName.py\u0026#39;, \u0026#39;zigzag.py\u0026#39;] json# Input\nimport json data = {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 28, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} json_str = json.dumps(data) data_back = json.loads(json_str) print(json_str) print(data_back)Output\n{\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 28, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\r{\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 28, \u0026#39;city\u0026#39;: \u0026#39;New York\u0026#39;} pandas# pandas là một thư viện Python cực kỳ mạnh mẽ và phổ biến, chuyên dùng để phân tích và xử lý dữ liệu (đặc biệt là dữ liệu dạng bảng) Input\nimport pandas as pd data = {\u0026#39;Name\u0026#39;: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;, \u0026#39;Devid\u0026#39;], \u0026#39;Age\u0026#39;: [25, 30, 35, 40], \u0026#39;City\u0026#39;: [\u0026#39;New York\u0026#39;, \u0026#39;Los Angles\u0026#39;, \u0026#39;Chicago\u0026#39;, \u0026#39;Houston\u0026#39;]} df = pd.DataFrame(data) print(\u0026#34;DataFrame:\u0026#34;) print(df) print(\u0026#34;\\nAccessing a Column:\u0026#34;) print(df[\u0026#39;Name\u0026#39;]) print(\u0026#34;\\nAccessing a Row:\u0026#34;) print(df.iloc[0]) print(\u0026#34;\\nApplying a function:\u0026#34;) df[\u0026#39;Age\u0026#39;] = df[\u0026#39;Age\u0026#39;].apply(lambda x: x + 5) print(df)Output\nDataFrame:\rName Age City\r0 Alice 25 New York\r1 Bob 30 Los Angles\r2 Charlie 35 Chicago\r3 Devid 40 Houston\rAccessing a Column\r0 Alice\r1 Bob\r2 Charlie\r3 Devid\rName: Name, dtype: object\rAccessing a Row:\rName Alice\rAge 25\rCity New York\rName: 0, dtype: object\rApplying a function:\rName Age City\r0 Alice 30 New York\r1 Bob 35 Los Angles\r2 Charlie 40 Chicago\r3 Devid 45 Houstonmatplotlib# Input\nimport matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] plt.plot(x, y) plt.xlabel(\u0026#39;X-axis\u0026#39;) plt.ylabel(\u0026#39;Y-axis\u0026#39;) plt.title(\u0026#39;line plot\u0026#39;) plt.show()\nInput\nimport matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] plt.scatter(x, y, color=\u0026#39;red\u0026#39;, marker=\u0026#39;o\u0026#39;) plt.xlabel(\u0026#39;X-axis\u0026#39;) plt.ylabel(\u0026#39;Y-axis\u0026#39;) plt.title(\u0026#39;Scatter plot\u0026#39;) plt.show() pyperclip# Input\nimport pyperclip pyperclip.copy(\u0026#39;Hello, world!\u0026#39;) print(pyperclip.paste())Result:\nHello, world!\nInput\nimport pyperclip print(pyperclip.paste())For example, if I copied this sentence to the clipboard and then called paste(), it would look like this:Output\nFor example, if I copied this sentence to the clipboard and then called paste(), it would look like this: random# Input\nimport random pets = [\u0026#39;Dog\u0026#39;, \u0026#39;Cat\u0026#39;, \u0026#39;Moose\u0026#39;] print(random.choice(pets))\nInput\nimport random people = [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Carol\u0026#39;, \u0026#39;David\u0026#39;] random.shuffle(people) print(people) copy# If the list you need to copy contains lists, use the copy.deepcopy() function instead of copy.copy(). The copy.deepcopy() function will copy these inner lists as well. Input\nimport copy spam = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] cheese = copy.copy(spam) # Creates a duplicate copy of the list cheese[1] = 42 # Changes cheese print(spam ) # The spam variable is unchanged print(cheese) # The cheese variable is changedOutput\n[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]\r[\u0026#39;A\u0026#39;, 42, \u0026#39;C\u0026#39;] "},{"id":17,"href":"/docs/note/programming-languages/python/09_regular-expressions/","title":"09_Regular-Expressions","section":"Python","content":"Regular Expressions# Finding Text Patterns with Regular Expressions# Input\nimport re phone_num_pattern_obj = re.compile(r\u0026#39;\\d{3}-\\d{3}-\\d{4}\u0026#39;) match_obj = phone_num_pattern_obj.search(\u0026#39;My number is 415-555-4242.\u0026#39;) print(match_obj.group())Output\n415-555-4242 Grouping with Parentheses# Input\nimport re phone_re = re.compile(r\u0026#39;(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)\u0026#39;) mo = phone_re.search(\u0026#39;My number is 415-555-4242.\u0026#39;) print(mo.group(1)) print(mo.group(2)) print(mo.group(0)) print(mo.group()) print(mo.groups()) area_code, main_number = mo.groups() print(area_code) print(main_number)Output\n415\r555-4242\r415-555-4242\r415-555-4242\r(\u0026#39;415\u0026#39;, \u0026#39;555-4242\u0026#39;)\r415\r555-4242 Using Escape Characters# Input\nimport re pattern = re.compile(r\u0026#39;(\\(\\d\\d\\d\\)) (\\d\\d\\d-\\d\\d\\d\\d)\u0026#39;)\\ mo = pattern.search(\u0026#39;My phone number is (415) 555-4242.\u0026#39;) print(mo.group(1)) print(mo.group(2))Output\n(415)\r555-4242 Matching Characters from Alternate Groups | |# Input\nimport re pattern = re.compile(r\u0026#39;Cat(erpillar|astrophe|ch|egory)\u0026#39;) match = pattern.search(\u0026#39;Catch me if you can.\u0026#39;) print(match.group()) print(match.group(1))Output\nCatch\rch Returning All Matches | findall()# Input\nimport re pattern = re.compile(r\u0026#39;\\d{3}-\\d{3}-\\d{4}\u0026#39;) # This regex has no groups print(pattern.findall(\u0026#39;Cell: 415-555-9999 Work: 212-555-0000\u0026#39;))Output\n[\u0026#39;415-555-9999\u0026#39;, \u0026#39;212-555-0000\u0026#39;]\nInput\nimport re pattern = re.compile(r\u0026#39;(\\d{3})-(\\d{3})-(\\d{4})\u0026#39;) # This regex has groups. print(pattern.findall(\u0026#39;Cell: 415-555-9999 Work: 212-555-0000\u0026#39;))Output\n[(\u0026#39;415\u0026#39;, \u0026#39;555\u0026#39;, \u0026#39;9999\u0026#39;), (\u0026#39;212\u0026#39;, \u0026#39;555\u0026#39;, \u0026#39;0000\u0026#39;)]\nInput\nimport re pattern = re.compile(r\u0026#39;\\d{3}\u0026#39;) print(pattern.findall(\u0026#39;1234\u0026#39;)) print(pattern.findall(\u0026#39;12345\u0026#39;)) print(pattern.findall(\u0026#39;123456\u0026#39;)) print(pattern.findall(\u0026#39;1234567\u0026#39;))Output\n[\u0026#39;123\u0026#39;]\r[\u0026#39;123\u0026#39;]\r[\u0026#39;123\u0026#39;, \u0026#39;456\u0026#39;]\r[\u0026#39;123\u0026#39;, \u0026#39;456\u0026#39;] Using Character Classes and Negative Character Classes# Input\nimport re vowel_pattern = re.compile(r\u0026#39;[aeiouAEIOU]\u0026#39;) print(vowel_pattern.findall(\u0026#39;RoboCop eats BABY FOOD.\u0026#39;))Output\n[\u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;O\u0026#39;]\nInput\nimport re consonant_pattern = re.compile(r\u0026#39;[^aeiouAEIOU]\u0026#39;) # By placing a caret character (^) just after the character class’s opening bracket, you can make a negative character class print(consonant_pattern.findall(\u0026#39;RoboCop eats BABY FOOD.\u0026#39;))Output\n[\u0026#39;R\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;.\u0026#39;] Using Shorthand Character Classes# Shorthand character class Represents \u0026hellip; \\d Any numeric digit from 0 to 9. \\D Any character that is not a numeric digit from 0 to 9. \\w Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters.) \\W Any character that is not a letter, numeric digit, or the underscore character. \\s Any space, tab, or newline character. (Think of this as matching “space” characters.) \\S Any character that is not a space, tab, or newline character. Input\nimport re pattern = re.compile(r\u0026#39;\\d+\\s\\w+\u0026#39;) # The regular expression \\d+\\s\\w+ will match text that has one or more numeric digits (\\d+), followed by a whitespace character (\\s), followed by one or more letter/digit/underscore characters (\\w+) print(pattern.findall(\u0026#39;12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge\u0026#39;))Output\n[\u0026#39;12 drummers\u0026#39;, \u0026#39;11 pipers\u0026#39;, \u0026#39;10 lords\u0026#39;, \u0026#39;9 ladies\u0026#39;, \u0026#39;8 maids\u0026#39;, \u0026#39;7 swans\u0026#39;, \u0026#39;6 geese\u0026#39;, \u0026#39;5 rings\u0026#39;, \u0026#39;4 birds\u0026#39;, \u0026#39;3 hens\u0026#39;, \u0026#39;2 doves\u0026#39;, \u0026#39;1 partridge\u0026#39;] Matching Everything with the Dot Character | .# Input\nimport re at_re = re.compile(r\u0026#39;.at\u0026#39;) print(at_re.findall(\u0026#39;The cat in the hat sat on the flat mat.\u0026#39;))Output\n[\u0026#39;cat\u0026#39;, \u0026#39;hat\u0026#39;, \u0026#39;sat\u0026#39;, \u0026#39;lat\u0026#39;, \u0026#39;mat\u0026#39;] Being Careful What You Match For# The best and worst thing about regular expressions is that they will match exactly what you ask for. Here are some common points of confusion regarding character classes: The [A-Z] or [a-z] character class matches uppercase or lowercase letters, respectively, but not both. You need to use [A-Za-z] to match both cases. + The [A-Za-z] character class matches only plain, unaccented letters. For example, the regex string r\u0026rsquo;First Name: ([A-Za-z]+)\u0026rsquo; would match “First Name: ” followed by a group of one or more unaccented letters. But singer Sinéad O’Connor’s first name would match up to the é only, and the group would be set to \u0026lsquo;Sin\u0026rsquo;. + The \\w character class matches all letters, including accented letters and characters from other alphabets. But it also matches numbers and the underscore character, so the regex string r\u0026rsquo;First Name: (\\w+)\u0026rsquo; may match more than you intended. + The \\w character class matches all letters, but the regex string r\u0026rsquo;Last Name: (\\w+)\u0026rsquo; would capture Sinéad O’Connor’s last name only up until the apostrophe character. This means the group would capture her last name as \u0026lsquo;O\u0026rsquo;. + Straight and smart quote characters (\u0026rsquo; \u0026quot; ‘ ’ “ ”) are considered completely different from each other and must be specified separately. Matching an Optional Pattern | ?# Input\nimport re # The ? part of the regular expression means that the pattern is optional pattern = re.compile(r\u0026#39;42?!\u0026#39;) print(pattern.search(\u0026#39;42!\u0026#39;)) print(pattern.search(\u0026#39;4!\u0026#39;)) print(pattern.search(\u0026#39;42\u0026#39;) == None) # No matchOutput\n\u0026lt;re.Match object; span=(0, 3), match=\u0026#39;42!\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 2), match=\u0026#39;4!\u0026#39;\u0026gt;\rTrue\nInput\nimport re pattern = re.compile(r\u0026#39;(\\d{3}-)?\\d{3}-\\d{4}\u0026#39;) match1 = pattern.search(\u0026#39;My number is 415-555-4242\u0026#39;) print(match1.group()) match2 = pattern.search(\u0026#39;My number is 555-4242\u0026#39;) print(match2.group()) Output\n415-555-4242\r555-4242 Matching Zero or More Qualifiers | *# Input\nimport re pattern = re.compile(\u0026#39;Eggs( and spam)*\u0026#39;) print(pattern.search(\u0026#39;Eggs\u0026#39;)) print(pattern.search(\u0026#39;Eggs and spam\u0026#39;)) print(pattern.search(\u0026#39;Eggs and spam and spam\u0026#39;)) print(pattern.search(\u0026#39;Eggs and spam and spam and spam\u0026#39;))Output\n\u0026lt;re.Match object; span=(0, 4), match=\u0026#39;Eggs\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 13), match=\u0026#39;Eggs and spam\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 22), match=\u0026#39;Eggs and spam and spam\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 31), match=\u0026#39;Eggs and spam and spam and spam\u0026#39;\u0026gt; Matching One or More Qualifiers | +# Input\nimport re pattern = re.compile(\u0026#39;Eggs( and spam)+\u0026#39;) print(pattern.search(\u0026#39;Eggs and spam\u0026#39;)) print(pattern.search(\u0026#39;Eggs and spam and spam\u0026#39;)) print(pattern.search(\u0026#39;Eggs and spam and spam and spam\u0026#39;))Output\n\u0026lt;re.Match object; span=(0, 4), match=\u0026#39;Eggs\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 13), match=\u0026#39;Eggs and spam\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 22), match=\u0026#39;Eggs and spam and spam\u0026#39;\u0026gt;\r\u0026lt;re.Match object; span=(0, 31), match=\u0026#39;Eggs and spam and spam and spam\u0026#39;\u0026gt; Matching a Specific Number of Qualifiers# Input\nimport re haRegex = re.compile(r\u0026#39;(Ha){3}\u0026#39;) match1 = haRegex.search(\u0026#39;HaHaHa\u0026#39;) print(match1.group()) match = haRegex.search(\u0026#39;HaHa\u0026#39;) print(match == None)Output\nHaHaHa\rTrue Greedy and Non-greedy Matching | ?, * and +# The ? quantifier is the same as {0,1}. The * quantifier is the same as {0,}. The + quantifier is the same as {1,}. Input\nimport re greedy_pattern = re.compile(r\u0026#39;(Ha){3,5}\u0026#39;) match1 = greedy_pattern.search(\u0026#39;HaHaHaHaHa\u0026#39;) print(match1.group()) lazy_pattern = re.compile(r\u0026#39;(Ha){3,5}?\u0026#39;) match2 = lazy_pattern.search(\u0026#39;HaHaHaHaHa\u0026#39;) print(match2.group())Output\nHaHaHaHaHa\rHaHaHa Matching Everything | .* and .*?# Input\nimport re name_pattern = re.compile(r\u0026#39;First Name: (.*) Last Name: (.*)\u0026#39;) name_match = name_pattern.search(\u0026#39;First Name: Al Last Name: Sweigart\u0026#39;) print(name_match.group(1)) print(name_match.group(2))Output\nAl\rSweigart The dot-star uses greedy mode: it will always try to match as much text as possible. To match any and all text in a non-greedy or lazy fashion, use the dot, star, and question mark (.*?). As when it’s used with curly brackets, the question mark tells Python to match in a non-greedy way. Input\nimport re lazy_pattern = re.compile(r\u0026#39;\u0026lt;.*?\u0026gt;\u0026#39;) match1 = lazy_pattern.search(\u0026#39;\u0026lt;To serve man\u0026gt; for dinner.\u0026gt;\u0026#39;) print(match1.group()) greedy_re = re.compile(r\u0026#39;\u0026lt;.*\u0026gt;\u0026#39;) match2 = greedy_re.search(\u0026#39;\u0026lt;To serve man\u0026gt; for dinner.\u0026gt;\u0026#39;) print(match2.group())Output\nAl\rSweigart Matching Newline Characters | re.DOTALL# Input\nimport re no_newline_re = re.compile(\u0026#39;.*\u0026#39;) print(no_newline_re.search(\u0026#39;Serve the public trust.\\nProtect the innocent. \\nUphold the law.\u0026#39;).group()) print() newline_re = re.compile(\u0026#39;.*\u0026#39;, re.DOTALL) print(newline_re.search(\u0026#39;Serve the public trust.\\nProtect the innocent. \\nUphold the law.\u0026#39;).group())Output\nServe the public trust.\rServe the public trust.\rProtect the innocent. Uphold the law. Matching at the Start and End of a String | ^, $ and /b# Input\nimport re begins_with_hello = re.compile(r\u0026#39;^Hello\u0026#39;) print(begins_with_hello.search(\u0026#39;Hello, world!\u0026#39;)) print(begins_with_hello.search(\u0026#39;He said \u0026#34;Hello.\u0026#34;\u0026#39;) == None)Output\n\u0026lt;re.Match object; span=(0, 5), match=\u0026#39;Hello\u0026#39;\u0026gt;\rTrue\nInput\nimport re ends_with_number = re.compile(r\u0026#39;\\d$\u0026#39;) print(ends_with_number.search(\u0026#39;Your number is 42\u0026#39;)) print(ends_with_number.search(\u0026#39;Your number is forty two.\u0026#39;) == None)Output\n\u0026lt;re.Match object; span=(16, 17), match=\u0026#39;2\u0026#39;\u0026gt;\rTrue\nInput\nimport re whole_string_is_num = re.compile(r\u0026#39;^\\d+$\u0026#39;) print(whole_string_is_num.search(\u0026#39;1234567890\u0026#39;)) print(whole_string_is_num.search(\u0026#39;12345xyz67890\u0026#39;) == None)Output\n\u0026lt;re.Match object; span=(0, 10), match=\u0026#39;1234567890\u0026#39;\u0026gt;\rTrue\nInput\nimport re pattern = re.compile(r\u0026#39;\\bcat.*?\\b\u0026#39;) print(pattern.findall(\u0026#39;The cat found a catapult catalog in the catacombs.\u0026#39;)) print() pattern = re.compile(r\u0026#39;\\Bcat\\B\u0026#39;) print(pattern.findall(\u0026#39;certificate\u0026#39;)) # Match print(pattern.findall(\u0026#39;catastrophe\u0026#39;)) # No matchOutput\n[\u0026#39;cat\u0026#39;, \u0026#39;catapult\u0026#39;, \u0026#39;catalog\u0026#39;, \u0026#39;catacombs\u0026#39;]\r[\u0026#39;cat\u0026#39;]\r[] Case-Insensitive Matching | re.I# Input\nimport re pattern = re.compile(r\u0026#39;robocop\u0026#39;, re.I) print(pattern.search(\u0026#39;RoboCop is part man, part machine, all cop.\u0026#39;).group()) print(pattern.search(\u0026#39;ROBOCOP protects the innocent.\u0026#39;).group()) print(pattern.search(\u0026#39;Have you seen robocop?\u0026#39;).group())Output\nRoboCop\rROBOCOP\rrobocop Substituting Strings | sub()# Input\nimport re pattern = re.compile(r\u0026#39;robocop\u0026#39;, re.I) agent_pattern = re.compile(r\u0026#39;Agent \\w+\u0026#39;) print(agent_pattern.sub(\u0026#39;CENSORED\u0026#39;, \u0026#39;Agent Alice contacted Agent Bob.\u0026#39;))Output\nCENSORED contacted CENSORED.\nInput\nimport re agent_pattern = re.compile(r\u0026#39;Agent (\\w)\\w*\u0026#39;) print(agent_pattern.sub(r\u0026#39;\\1****\u0026#39;, \u0026#39;Agent Alice contacted Agent Bob.\u0026#39;))Output\nA**** contacted B****. Managing Complex Regexes with Verbose Mode | re.VERBOSE# Input\npattern = re.compile(r\u0026#39;\u0026#39;\u0026#39;( (\\d{3}|\\(\\d{3}\\))? # Area code (\\s|-|\\.)? # Separator \\d{3} # First three digits (\\s|-|\\.) # Separator \\d{4} # Last four digits (\\s*(ext|x|ext\\.)\\s*\\d{2,5})? # Extension )\u0026#39;\u0026#39;\u0026#39;, re.VERBOSE) "},{"id":18,"href":"/docs/note/programming-languages/python/10_debugging/","title":"10_Debugging","section":"Python","content":"Debugging# Exception Handling# Input\ndef spam(divide_by): try: return 42 / divide_by except ZeroDivisionError: print(\u0026#39;Error: Invalid argument.\u0026#39;) print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))Output\n21.0\r3.5\rError: Invalid argument.\rNone\r42.0\nInput\ndef spam(divide_by): return 42 / divide_by try: print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) except ZeroDivisionError: print(\u0026#39;Error: Invalid argument.\u0026#39;)Output\n21.0\r3.5\rError: Invalid argument. Raising Exceptions# Input\nraise Exception(\u0026#39;This is the error message.\u0026#39;)Output\nTraceback (most recent call last):\rFile \u0026#34;\u0026lt;pyshell#191\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\rraise Exception(\u0026#39;This is the error message.\u0026#39;)\rException: This is the error message.\nInput\ndef box_print(symbol, width, height): if len(symbol) != 1: raise Exception(\u0026#39;Symbol must be a single character string.\u0026#39;) if width \u0026lt;= 2: raise Exception(\u0026#39;Width must be greater than 2.\u0026#39;) if height \u0026lt;= 2: raise Exception(\u0026#39;Height must be greater than 2.\u0026#39;) print(symbol * width) for i in range(height - 2): print(symbol + (\u0026#39; \u0026#39; * (width - 2)) + symbol) print(symbol * width) try: box_print(\u0026#39;*\u0026#39;, 4, 4) box_print(\u0026#39;O\u0026#39;, 20, 5) box_print(\u0026#39;x\u0026#39;, 1, 3) box_print(\u0026#39;ZZ\u0026#39;, 3, 3) except Exception as err: print(\u0026#39;An exception happened: \u0026#39; + str(err)) try: box_print(\u0026#39;ZZ\u0026#39;, 3, 3) except Exception as err: print(\u0026#39;An exception happened: \u0026#39; + str(err))Output\n****\r* *\r* *\r****\rOOOOOOOOOOOOOOOOOOOO\rO O\rO O\rO O\rOOOOOOOOOOOOOOOOOOOO\rAn exception happened: Width must be greater than 2.\rAn exception happened: Symbol must be a single character string. Assertions# Input\nages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] ages.sort() assert ages[0] \u0026lt;= ages[-1] # Assert that the first age is \u0026lt;= the last ageOutput\nInput\nages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] ages.reverse() assert ages[0] \u0026lt;= ages[-1] # Assert that the first age is \u0026lt;= the last ageOutput\nTraceback (most recent call last):\rFile \u0026#34;\u0026lt;python-input-0\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\rAssertionError The logging Module# Input\nimport logging logging.basicConfig(level=logging.DEBUG, format=\u0026#39;%(asctime)s - %(levelname)s - %(message)s\u0026#39;) logging.debug(\u0026#39;Start of program\u0026#39;) def factorial(n): logging.debug(\u0026#39;Start of factorial(\u0026#39; + str(n) + \u0026#39;)\u0026#39;) total = 1 for i in range(n + 1): total *= i logging.debug(\u0026#39;i is \u0026#39; + str(i) + \u0026#39;, total is \u0026#39; + str(total)) logging.debug(\u0026#39;End of factorial(\u0026#39; + str(n) + \u0026#39;)\u0026#39;) return total print(factorial(5)) logging.debug(\u0026#39;End of program\u0026#39;)Output\n2025-11-02 22:53:01,430 - DEBUG - Start of program\r2025-11-02 22:53:01,430 - DEBUG - Start of factorial(5)\r2025-11-02 22:53:01,430 - DEBUG - i is 0, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 1, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 2, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 3, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 4, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 5, total is 0\r2025-11-02 22:53:01,430 - DEBUG - End of factorial(5)\r0\r2025-11-02 22:53:01,430 - DEBUG - End of program Logfiles# Input\nimport logging logging.basicConfig(filename=\u0026#39;myProgramLog.txt\u0026#39;, level=logging.DEBUG, format=\u0026#39; %(asctime)s - %(levelname)s - %(message)s\u0026#39;) Logging Levels# Level Logging function Description DEBUG logging.debug() The lowest level, used for small details. Usually, you’ll care about these messages only when diagnosing problems. INFO logging.info() Used to record information about general events in your program or to confirm that it’s working at various points. WARNING logging.warning() Used to indicate a potential problem that doesn’t prevent the program from working but might do so in the future. ERROR logging.error() Used to record an error that caused the program to fail to do something. CRITICAL logging.critical() The highest level, used to indicate a fatal error that has caused, or is about to cause, the program to stop running entirely. Passing logging.DEBUG to the basicConfig() function’s level named parameter will show messages from all the logging levels (DEBUG being the lowest level). But after developing your program some more, you may be interested only in errors. In that case, you can set basicConfig()’s level argument to logging.ERROR. This will show only ERROR and CRITICAL messages and will skip the DEBUG, INFO, and WARNING messages. Disabled Logging# Input\nimport logging logging.basicConfig(level=logging.INFO, format=\u0026#39; %(asctime)s - %(levelname)s - %(message)s\u0026#39;) logging.critical(\u0026#39;Critical error! Critical error!\u0026#39;) logging.disable(logging.CRITICAL) logging.critical(\u0026#39;Critical error! Critical error!\u0026#39;) logging.error(\u0026#39;Error! Error!\u0026#39;)Output\n2025-11-02 22:39:52,251 - CRITICAL - Critical error! Critical error!\nInput\nimport logging logging.basicConfig(level=logging.INFO, format=\u0026#39; %(asctime)s - %(levelname)s - %(message)s\u0026#39;) logging.critical(\u0026#39;Critical error! Critical error!\u0026#39;) logging.disable(logging.ERROR) logging.critical(\u0026#39;Critical error! Critical error!\u0026#39;) logging.error(\u0026#39;Error! Error!\u0026#39;)Output\n2025-11-02 22:41:46,767 - CRITICAL - Critical error! Critical error!\r2025-11-02 22:41:46,767 - CRITICAL - Critical error! Critical error! Finally# Input\ntry: result = 20 / 2 except ZeroDivisionError: print(\u0026#34;error: division by zero is not allowed.\u0026#34;) else: print(\u0026#34;Division successful, result is : \u0026#34;, result) finally: print(\u0026#34;This block always executes\u0026#34;)Output\nDivision successful, result is : 10.0\rThis block always executes "}]