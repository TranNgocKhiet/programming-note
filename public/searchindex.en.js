var relearn_searchindex = [
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Cloud",
    "content": "AWS Lambda",
    "description": "AWS Lambda",
    "tags": [],
    "title": "AWS",
    "uri": "/note/05_cloud/aws/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Cloud \u003e AWS",
    "content": "With Dynamo and Cognito",
    "description": "With Dynamo and Cognito",
    "tags": [],
    "title": "AWS Lambda",
    "uri": "/note/05_cloud/aws/lambda/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Operating System \u003e Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Bash",
    "uri": "/note/02_operating-system/linux/bash/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control \u003e Gitlab \u003e CI/CD Template",
    "content": "Android.gitlab-ci.yml Bash.gitlab-ci.yml C++.gitlab-ci.yml Clojure.gitlab-ci.yml Composer.gitlab-ci.yml Crystal.gitlab-ci.yml Dart.gitlab-ci.yml\rDjango.gitlab-ci.yml dotNET.gitlab-ci.yml Elixir.gitlab-ci.yml Flutter.gitlab-ci.yml Go.gitlab-ci.yml Gradle.gitlab-ci.yml Grails.gitlab-ci.yml iOS-Fastlane.gitlab-ci.yml Java.gitlab-ci.yml Jekyll.gitlab-ci.yml Julia.gitlab-ci.yml Laravel.gitlab-ci.yml LaTeX.gitlab-ci.yml Maven.gitlab-ci.yml Mono.gitlab-ci.yml Nodejs.gitlab-ci.yml OCaml.gitlab-ci.yml Packer.gitlab-ci.yml PHP.gitlab-ci.yml Python.gitlab-ci.yml Rails.gitlab-ci.yml Ruby.gitlab-ci.yml Rust.gitlab-ci.yml Scala.gitlab-ci.yml Swift.gitlab-ci.yml Symfony.gitlab-ci.yml Wordpress.gitlab-ci.yml Docker.gitlab-ci.yml\rKaniko.gitlab-ci.yml\rBuildah.gitlab-ci.yml\rGodot.gitlab-ci.yml\rKiCad.gitlab-ci.yml\rAuto-DevOps.gitlab-ci.yml",
    "description": "Android.gitlab-ci.yml Bash.gitlab-ci.yml C++.gitlab-ci.yml Clojure.gitlab-ci.yml Composer.gitlab-ci.yml Crystal.gitlab-ci.yml Dart.gitlab-ci.yml\rDjango.gitlab-ci.yml dotNET.gitlab-ci.yml Elixir.gitlab-ci.yml Flutter.gitlab-ci.yml Go.gitlab-ci.yml Gradle.gitlab-ci.yml Grails.gitlab-ci.yml iOS-Fastlane.gitlab-ci.yml Java.gitlab-ci.yml Jekyll.gitlab-ci.yml Julia.gitlab-ci.yml Laravel.gitlab-ci.yml LaTeX.gitlab-ci.yml Maven.gitlab-ci.yml Mono.gitlab-ci.yml Nodejs.gitlab-ci.yml OCaml.gitlab-ci.yml Packer.gitlab-ci.yml PHP.gitlab-ci.yml Python.gitlab-ci.yml Rails.gitlab-ci.yml Ruby.gitlab-ci.yml Rust.gitlab-ci.yml Scala.gitlab-ci.yml Swift.gitlab-ci.yml Symfony.gitlab-ci.yml Wordpress.gitlab-ci.yml Docker.gitlab-ci.yml\rKaniko.gitlab-ci.yml\rBuildah.gitlab-ci.yml\rGodot.gitlab-ci.yml\rKiCad.gitlab-ci.yml\rAuto-DevOps.gitlab-ci.yml",
    "tags": [],
    "title": "Build \u0026 Test Template",
    "uri": "/note/03_source-control/gitlab/02_ci-cd-template/a_build_and_test_template/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control \u003e Gitlab",
    "content": "Create SSH Key\rssh-keygen -t ed25519 -C \"email-gitlab-cua-ban@example.com\"\rCan skip the key password if not necessary Show Key\rcat ~/.ssh/id_ed25519.pub\rAdd key to Gitlab\rĐăng nhập vào GitLab.com. Click vào ảnh đại diện (avatar) của bạn ở góc trên bên phải, chọn Preferences. Trong menu điều hướng bên trái, chọn SSH Keys. Paste (dán) key từ terminal vào ô “Key”. Đặt tên cho key Nhấn nút Add key. Check connection\rssh -T git@gitlab.com",
    "description": "Create SSH Key\rssh-keygen -t ed25519 -C \"email-gitlab-cua-ban@example.com\"\rCan skip the key password if not necessary Show Key\rcat ~/.ssh/id_ed25519.pub\rAdd key to Gitlab\rĐăng nhập vào GitLab.com. Click vào ảnh đại diện (avatar) của bạn ở góc trên bên phải, chọn Preferences. Trong menu điều hướng bên trái, chọn SSH Keys. Paste (dán) key từ terminal vào ô “Key”. Đặt tên cho key Nhấn nút Add key. Check connection\rssh -T git@gitlab.com",
    "tags": [],
    "title": "Create Connection",
    "uri": "/note/03_source-control/gitlab/01_create-connection/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "NoneType\rIn Python, a value called None represents the absence of a value. The None value is the only value of the NoneType data type. (Other programming languages might call this value null, nil, or undefined). Just like the Boolean True and False values, you must always write None with a capital N. Input\nspam = print('Hello!') None == spam\rOuput\nTrue\rSequence Data Types\rThe Python sequence data types include lists, strings, range objects returned by range(), and tuples. Mutable and Immutable Data types\rA list value is a mutable data type: you can add, remove, or change its values; however, a string is immutable: it cannot be changed Input\nname = 'Zophie a cat' name[7] = 'the'\rOutput\nTraceback (most recent call last):\rFile \"\u003cpython-input-0\u003e\", line 1, in \u003cmodule\u003e\rname[7] = 'the'\rTypeError: 'str' object does not support item assignment\rThe proper way to “mutate” a string is to use slicing and concatenation to build a new string by copying from parts of the old string print(new_name) Input\nname = 'Zophie a cat' new_name = name[0:7] + 'the' + name[8:12]\rOutput\nZophie the cat\rList Data Type\rDictionary Data Type\rString Data Type\rTuple Data Type\rSet Data Type\rData Type Comparision",
    "description": "NoneType\rIn Python, a value called None represents the absence of a value. The None value is the only value of the NoneType data type. (Other programming languages might call this value null, nil, or undefined). Just like the Boolean True and False values, you must always write None with a capital N. Input\nspam = print('Hello!') None == spam\rOuput",
    "tags": [],
    "title": "Data Structures",
    "uri": "/note/01_programming-language/python/01_data-structures/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control",
    "content": "",
    "description": "",
    "tags": [],
    "title": "GitHub",
    "uri": "/note/03_source-control/github/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Hello, my name is Tran Ngoc Khiet I am student at FPT University HCM Campus I am on the job training at AWS This is my programming note page Hope it is useful for you Thank you for viewing this page \u003c3\nProgramming Note",
    "description": "Hello, my name is Tran Ngoc Khiet I am student at FPT University HCM Campus I am on the job training at AWS This is my programming note page Hope it is useful for you Thank you for viewing this page \u003c3\nProgramming Note",
    "tags": [],
    "title": "Home Page",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Operating System",
    "content": "Bash\rCommands\rUbuntu",
    "description": "Bash\rCommands\rUbuntu",
    "tags": [],
    "title": "Linux",
    "uri": "/note/02_operating-system/linux/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python \u003e Data Structures",
    "content": "Syntax\rInput\nsquares = [x**2 for x in range(10)] print(squares)\rOutput\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\rInput\nproducts = [i * j for j in range(3) for i in range(3)] print(products)\rOutput\n[0, 0, 0, 0, 1, 2, 0, 2, 4]\rInput\nwords = ['apple', 'banana', 'orange'] lengths = [len(word) for word in words] print(lengths)\rOutput\n[5, 6, 6]\rFinding Index | index()\rInput\nspam = ['hello', 'hi', 'howdy', 'heyas'] print(spam.index('hello'))\rOutput\n0\rInput\nspam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] print(spam.index('Pooka')) # When the list contains duplicates of the value, the method returns the index of its first appearance\rOutput\n1\rAdding Values | append()\rInput\nspam = ['cat', 'dog', 'bat'] spam.append('moose') print(spam)\rOutput\n['cat', 'dog', 'bat', 'moose']\rInput\nspam = ['cat', 'dog', 'bat'] spam.insert(1, 'chicken') print(spam)\rOutput\n['cat', 'chicken', 'dog', 'bat']\rRemoving Values | remove()\rInput\nspam = ['cat', 'bat', 'rat', 'elephant'] spam.remove('bat') print(spam)\rOutput\n['cat', 'rat', 'elephant']\rIf the value appears multiple times in the list, the method will remove only the first instance of it Input\nspam = ['cat', 'bat', 'rat', 'cat', 'hat', 'cat'] spam.remove('cat') print(spam)\rOutput\n['bat', 'rat', 'cat', 'hat', 'cat']\rPop Values | pop()\rInput\nmy_list = [1, 2, 3, 4, 5] popped_element = my_list.pop() print(popped_element) print(my_list)\rOutput\n5\r[1, 2, 3, 4]\rSorting Values | sort()\rInput\nspam = [2, 5, 3.14, 1, -7] spam.sort() print(spam) spam = ['Ants', 'Cats', 'Dogs', 'Badgers', 'Elephants'] spam.sort() print(spam)\rOutput\n[-7, 1, 2, 3.14, 5]\r['Ants', 'Badgers', 'Cats', 'Dogs', 'Elephants']\rInput\nspam = ['Ants', 'Cats', 'Dogs', 'Badgers', 'Elephants'] spam.sort(reverse=True) print(spam)\rOutput\n['Elephants', 'Dogs', 'Cats', 'Badgers', 'Ants']\rsort() uses ASCIIbetical order rather than actual alphabetical order for sorting strings, this means uppercase letters come before lowercase letters, placing the lowercase a after the uppercase Z Input\nspam = ['Alice', 'ants', 'Bob', 'badgers', 'Carol', 'cats'] spam.sort() print(spam)\rOutput\n['Alice', 'Bob', 'Carol', 'ants', 'badgers', 'cats']\rCan’t sort lists that have both number values and string values in them, as Python doesn’t know how to compare these values Input\nspam = [1, 3, 2, 4, 'Alice', 'Bob'] spam.sort() print(spam)\rOutput\nTraceback (most recent call last):\rFile \"\u003cpython-input-0\u003e\", line 1, in \u003cmodule\u003e\rspam.sort()\rTypeError: '\u003c' not supported between instances of 'str' and 'int'\rInput\nspam = ['a', 'z', 'A', 'Z'] spam.sort(key=str.lower) print(spam)\rOutput\n['a', 'A', 'z', 'Z']\rReversing Values | reverse()\rInput\nspam = ['cat', 'dog', 'moose'] spam.reverse() print(spam)\rOutput\n['moose', 'dog', 'cat']\rList Item Enumeration | enumerate()\rInput\nsupplies = ['pens', 'staplers', 'flamethrowers', 'binders'] for index, item in enumerate(supplies): print('Index ' + str(index) + ' in supplies is: ' + item)\rOutput\nIndex 0 in supplies is: pens\rIndex 1 in supplies is: staplers\rIndex 2 in supplies is: flamethrowers\rIndex 3 in supplies is: binders\rNegative Indexes\rInput\nspam = ['cat', 'bat', 'rat', 'elephant'] print('The ' + spam[-1] + ' is afraid of the ' + spam[-3] + '.')\rOutput\nThe elephant is afraid of the bat.\rSlices\rInput\nspam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1])\rOutput\n['cat', 'bat', 'rat', 'elephant']\r['bat', 'rat']\r['cat', 'bat', 'rat']\rInput\nspam = ['cat', 'bat', 'rat', 'elephant'] print(spam[:2]) print(spam[1:]) print(spam[:])\rOutput\n['cat', 'bat']\r['bat', 'rat', 'elephant']\r['cat', 'bat', 'rat', 'elephant']\rThe Multiple Assignment Trick\rInput\ncat = ['fat', 'gray', 'loud'] size, color, disposition = cat print(size, color, disposition)\rOutput\nfat gray loud",
    "description": "Syntax\rInput\nsquares = [x**2 for x in range(10)] print(squares)\rOutput\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\rInput\nproducts = [i * j for j in range(3) for i in range(3)] print(products)\rOutput\n[0, 0, 0, 0, 1, 2, 0, 2, 4]\rInput\nwords = ['apple', 'banana', 'orange'] lengths = [len(word) for word in words] print(lengths)\rOutput\n[5, 6, 6]\rFinding Index | index()\rInput",
    "tags": [],
    "title": "List Data Type",
    "uri": "/note/01_programming-language/python/01_data-structures/a_list_data_type/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note",
    "content": "Python",
    "description": "Python",
    "tags": [],
    "title": "Programming Language",
    "uri": "/note/01_programming-language/index.html"
  },
  {
    "breadcrumb": "Home Page",
    "content": "Programming Language\rOperating System\rSource Control\rVirtual Machine\rCloud\rOffice",
    "description": "Programming Language\rOperating System\rSource Control\rVirtual Machine\rCloud\rOffice",
    "tags": [],
    "title": "Programming Note",
    "uri": "/note/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language",
    "content": "Source References\rBooks\rAutomate the Boring Stuff with Python by Al Sweigart\nCourses\rPython Mastery: The Complete Web Programming Course by Knowledge Nest on Udemy\nData Structures\rOperators\rStatements\rFunctions\rParameters\rClasses\rFiles\rLibraries\rDebugging\rRegular Expressions",
    "description": "Source References\rBooks\rAutomate the Boring Stuff with Python by Al Sweigart\nCourses\rPython Mastery: The Complete Web Programming Course by Knowledge Nest on Udemy\nData Structures\rOperators\rStatements\rFunctions\rParameters\rClasses\rFiles\rLibraries\rDebugging\rRegular Expressions",
    "tags": [],
    "title": "Python",
    "uri": "/note/01_programming-language/python/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Virtual Machine",
    "content": "Link download\rhttps://www.virtualbox.org/wiki/Downloads\nVideo reference\rhttps://www.youtube.com/watch?v=lmeDvSgN6zY",
    "description": "Link download\rhttps://www.virtualbox.org/wiki/Downloads\nVideo reference\rhttps://www.youtube.com/watch?v=lmeDvSgN6zY",
    "tags": [],
    "title": "Virtual Box",
    "uri": "/note/04_virtual-machine/virtual-box/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Cloud \u003e AWS \u003e AWS Lambda",
    "content": "import boto3 import json import os # Create client and handler dynamodb = boto3.resource('dynamodb') cognito_client = boto3.client('cognito-idp') # Get environment variables TABLE_NAME = os.environ.get('TABLE_NAME') USER_POOL_ID = os.environ.get('USER_POOL_ID') table = dynamodb.Table(TABLE_NAME) def build_update_params(updates): update_expression = \"SET \" expression_names = {} expression_values = {} # Use #name and #email to avoid reserved words attribute_map = { \"name\": \"#name\", \"email\": \"#email\", } for key, value in updates.items(): if key in attribute_map: placeholder = f\":{key}\" attr_name = attribute_map[key] update_expression += f\"{attr_name} = {placeholder}, \" expression_values[placeholder] = value expression_names[attr_name] = key update_expression = update_expression.rstrip(\", \") return update_expression, expression_names, expression_values def lambda_handler(event, context): try: if \"body\" in event: body = json.loads(event[\"body\"]) else: body = event user_id = body.get('userId') updates = body.get('updates') if not user_id or not updates: return {'statusCode': 400, 'body': 'Lỗi: Thiếu \"userId\" hoặc \"updates\"'} update_expr, attr_names, attr_values = build_update_params(updates) if not attr_values: return {'statusCode': 400, 'body': 'Không có trường hợp lệ nào để cập nhật'} dynamo_response = table.update_item( Key={'userId': user_id}, UpdateExpression=update_expr, ExpressionAttributeNames=attr_names, ExpressionAttributeValues=attr_values, ReturnValues=\"UPDATED_NEW\" ) if 'email' in updates: new_email = updates['email'] try: cognito_client.admin_update_user_attributes( UserPoolId=USER_POOL_ID, Username=user_id, UserAttributes=[ { 'Name': 'email', 'Value': new_email }, { 'Name': 'email_verified', 'Value': 'true' } ] ) except Exception as e: print(f\"Cognito Error: {e}\") return { 'statusCode': 500, 'body': f'Update DynamoDB success, but failed to update Cognito: {str(e)}' } success_body = { \"message\": \"Update success\", \"updatedAttributes\": dynamo_response.get('Attributes') } return { 'statusCode': 200, 'body': json.dumps(success_body) } except Exception as e: print(f\"Unknow error: {e}\") return { 'statusCode': 500, 'body': f'Error when handle request: {str(e)}' }\rDeclare and initialize\rimport boto3 import json import os dynamodb = boto3.resource('dynamodb') cognito_client = boto3.client('cognito-idp') TABLE_NAME = os.environ.get('TABLE_NAME') USER_POOL_ID = os.environ.get('USER_POOL_ID') table = dynamodb.Table(TABLE_NAME)\rimport boto3: Thư viện (SDK) chính thức của AWS cho Python, dùng để tương tác với các AWS Service import json: Dùng để xử lý dữ liệu JSON (ví dụ: event[\"body\"]) import os: Dùng để đọc các Environment variables trong Configuration của Lambda dynamodb = boto3.resource('dynamodb'): Sử dụng giao diện “resource” (cấp cao, dễ dùng hơn) của boto3 cho DynamoDB cognito_client = boto3.client('cognito-idp'): Sử dụng giao diện “client” (cấp thấp, chi tiết hơn) cho Cognito Identity Provider TABLE_NAME = os.environ.get('TABLE_NAME'): Tên của bảng DynamoDB chứa thông tin người dùng USER_POOL_ID = os.environ.get('USER_POOL_ID'): ID của Cognito User Pool nơi người dùng được quản lý table = dynamodb.Table(TABLE_NAME): Tạo một đối tượng Table cụ thể từ dynamodb resource, trỏ đến bảng có tên là TABLE_NAME. Điều này giúp thực hiện các thao tác (như update_item) trực tiếp trên bảng đó build_update_params Function\rdef build_update_params(updates):: Khai báo tên hàm, tên tham số update_expression = \"SET \": Chuỗi lệnh SET cho DynamoDB (ví dụ: SET #name = :name, #email = :email) expression_names = {}: Một dictionary để map tên giữ chỗ (placeholder) với tên thuộc tính thật. Ví dụ: {\"#name\": \"name\"}. Điều này rất quan trọng để tránh lỗi với các từ khóa dự trữ (reserved words) của DynamoDB (như name) expression_values = {}: Một dictionary để map tên giữ chỗ với giá trị thật. Ví dụ: {\":name\": \"John Doe\"}. Điều này giúp ngăn ngừa lỗi SQL injection (mặc dù đây là NoSQL, nguyên tắc tương tự) attribute_map = { \"name\": \"#name\", \"email\": \"#email\", }\rĐịnh nghĩa một attribute_map. Nó chỉ định rằng nếu updates có chứa “name” hoặc “email”, chúng ta sẽ sử dụng tên giữ chỗ là #name và #email trong UpdateExpression for key, value in updates.items(): if key in attribute_map: placeholder = f\":{key}\" attr_name = attribute_map[key] update_expression += f\"{attr_name} = {placeholder}, \" expression_values[placeholder] = value expression_names[attr_name] = key\rfor key, value in updates.items():: Lặp qua từng cặp key (tên trường) và value (giá trị mới) trong dictionary updates mà người dùng gửi lên\nif key in attribute_map:: (Quan trọng) Chỉ xử lý nếu key (ví dụ: “name”) có trong attribute_map. Nếu người dùng gửi một trường không có trong map (ví dụ: {\"age\": 30}), nó sẽ bị bỏ qua\nNếu trường hợp lệ: + placeholder = f\":{key}\": Tạo tên giữ chỗ cho giá trị (ví dụ: :name) + attr_name = attribute_map[key]1: Lấy tên giữ chỗ cho thuộc tính (ví dụ: #name) + update_expression += f\"{attr_name} = {placeholder}, \": Thêm vào chuỗi update_expression (ví dụ: SET #name = :name, ) + expression_values[placeholder] = value: Thêm giá trị vào expression_values (ví dụ: {\":name\": \"John Doe\"}) + expression_names[attr_name] = key: Thêm tên vào expression_names (ví dụ: {\"#name\": \"name\"})\nupdate_expression = update_expression.rstrip(\", \"): Xóa dấu phẩy và khoảng trắng thừa ở cuối chuỗi update_expression\nreturn update_expression, expression_names, expression_values: Trả về 3 thành phần đã được xây dựng\nlambda_handler Function\rUpdate DynamoDB\rdef lambda_handler(event, context):: Khai báo tên hàm, tên tham số try:: Bắt đầu một khối try...except lớn để bắt bất kỳ lỗi không mong muốn nào if \"body\" in event: body = json.loads(event[\"body\"]) else: body = event\rXử lý event. Nếu Lambda này được kích hoạt bởi API Gateway, dữ liệu POST/PUT sẽ nằm trong event[\"body\"] dưới dạng một chuỗi JSON. Cần json.loads để biến nó thành dictionary. Nếu không, (ví dụ: chạy test trực tiếp trong Lambda), event chính là body\nuser_id = body.get('userId'): Lấy userId\nupdates = body.get('updates'): Lấy dictionary updates\nif not user_id or not updates: return {'statusCode': 400, 'body': 'Lỗi: Thiếu \"userId\" hoặc \"updates\"'}\rKiểm tra xem userId và updates có tồn tại không. Nếu thiếu, trả về lỗi 400 Bad Request\nupdate_expr, attr_names, attr_values = build_update_params(updates): Gọi hàm build_update_params đã giải thích ở trên\nif not attr_values: return {'statusCode': 400, 'body': 'Không có trường hợp lệ nào để cập nhật'}\rNếu attr_values rỗng (nghĩa là người dùng đã gửi updates nhưng không chứa “name” hay “email”), trả về lỗi 400 dynamo_response = table.update_item( Key={'userId': user_id}, UpdateExpression=update_expr, ExpressionAttributeNames=attr_names, ExpressionAttributeValues=attr_values, ReturnValues=\"UPDATED_NEW\" )\rdynamo_response = table.update_item(): Đây là lệnh chính thức cập nhật DynamoDB Key={'userId': user_id}: Chỉ định item nào cần cập nhật (dựa trên Primary Key) Cung cấp 3 tham số đã được tạo ra bởi hàm build_update_params ReturnValues=\"UPDATED_NEW\": Yêu cầu DynamoDB trả về giá trị mới của các thuộc tính vừa được cập nhật Update Cognito\rif 'email' in updates: new_email = updates['email'] try: cognito_client.admin_update_user_attributes( UserPoolId=USER_POOL_ID, Username=user_id, UserAttributes=[ { 'Name': 'email', 'Value': new_email }, { 'Name': 'email_verified', 'Value': 'true' } ] )\rif 'email' in updates:: Chỉ thực hiện khối này nếu email là một trong các trường được yêu cầu cập nhật new_email = updates['email']: Lấy địa chỉ email mới try:: Bắt đầu một khối ```try…except`` lồng nhau. Điều này rất quan trọng: nó cho phép bắt lỗi Cognito một cách riêng biệt cognito_client.admin_update_user_attributes(): Gọi hàm admin_update_user_attributes của Cognito UserPoolId=USER_POOL_ID,: Chỉ định UserPoolId Username=user_id,: Chỉ định Username (trong Cognito, Username thường chính là userId hoặc sub của người dùng) Cập nhật thuộc tính email thành giá trị mới, và đồng thời đánh dấu email_verified là true. Đây là một hành động “admin”, giả định rằng email do admin cập nhật là đã được xác thực except Exception as e: print(f\"Cognito Error: {e}\") return { 'statusCode': 500, 'body': f'Update DynamoDB success, but failed to update Cognito: {str(e)}' }\rNếu có lỗi xảy ra chỉ với Cognito (ví dụ: email không hợp lệ, người dùng không tồn tại trong Cognito), hàm sẽ dừng và trả về lỗi 500, nó nói rõ: “Update DynamoDB success, but failed to update Cognito” Return Successs and catch general Exception\rsuccess_body = { \"message\": \"Update success\", \"updatedAttributes\": dynamo_response.get('Attributes') } return { 'statusCode': 200, 'body': json.dumps(success_body) }\rNếu mọi thứ chạy suôn sẻ (cả DynamoDB và Cognito (nếu có)), tạo một body phản hồi thành công. Nó bao gồm các thuộc tính đã được cập nhật lấy từ dynamo_response (nhờ ReturnValues=\"UPDATED_NEW\") Trả về phản hồi 200 OK với body đã được chuyển thành chuỗi JSON except Exception as e: print(f\"Unknow error: {e}\") return { 'statusCode': 500, 'body': f'Error when handle request: {str(e)}' }\rexcept Exception as e:: Đây là khối except của try lớn bên ngoài Nếu có bất kỳ lỗi nào khác xảy ra (ví dụ: lỗi parse JSON, lỗi DynamoDB, lỗi Evironment variables bị thiếu…), nó sẽ bị bắt ở đây và trả về lỗi 500 Internal Server Error",
    "description": "import boto3 import json import os # Create client and handler dynamodb = boto3.resource('dynamodb') cognito_client = boto3.client('cognito-idp') # Get environment variables TABLE_NAME = os.environ.get('TABLE_NAME') USER_POOL_ID = os.environ.get('USER_POOL_ID') table = dynamodb.Table(TABLE_NAME) def build_update_params(updates): update_expression = \"SET \" expression_names = {} expression_values = {} # Use #name and #email to avoid reserved words attribute_map = { \"name\": \"#name\", \"email\": \"#email\", } for key, value in updates.items(): if key in attribute_map: placeholder = f\":{key}\" attr_name = attribute_map[key] update_expression += f\"{attr_name} = {placeholder}, \" expression_values[placeholder] = value expression_names[attr_name] = key update_expression = update_expression.rstrip(\", \") return update_expression, expression_names, expression_values def lambda_handler(event, context): try: if \"body\" in event: body = json.loads(event[\"body\"]) else: body = event user_id = body.get('userId') updates = body.get('updates') if not user_id or not updates: return {'statusCode': 400, 'body': 'Lỗi: Thiếu \"userId\" hoặc \"updates\"'} update_expr, attr_names, attr_values = build_update_params(updates) if not attr_values: return {'statusCode': 400, 'body': 'Không có trường hợp lệ nào để cập nhật'} dynamo_response = table.update_item( Key={'userId': user_id}, UpdateExpression=update_expr, ExpressionAttributeNames=attr_names, ExpressionAttributeValues=attr_values, ReturnValues=\"UPDATED_NEW\" ) if 'email' in updates: new_email = updates['email'] try: cognito_client.admin_update_user_attributes( UserPoolId=USER_POOL_ID, Username=user_id, UserAttributes=[ { 'Name': 'email', 'Value': new_email }, { 'Name': 'email_verified', 'Value': 'true' } ] ) except Exception as e: print(f\"Cognito Error: {e}\") return { 'statusCode': 500, 'body': f'Update DynamoDB success, but failed to update Cognito: {str(e)}' } success_body = { \"message\": \"Update success\", \"updatedAttributes\": dynamo_response.get('Attributes') } return { 'statusCode': 200, 'body': json.dumps(success_body) } except Exception as e: print(f\"Unknow error: {e}\") return { 'statusCode': 500, 'body': f'Error when handle request: {str(e)}' }\rDeclare and initialize\rimport boto3 import json import os dynamodb = boto3.resource('dynamodb') cognito_client = boto3.client('cognito-idp') TABLE_NAME = os.environ.get('TABLE_NAME') USER_POOL_ID = os.environ.get('USER_POOL_ID') table = dynamodb.Table(TABLE_NAME)\rimport boto3: Thư viện (SDK) chính thức của AWS cho Python, dùng để tương tác với các AWS Service import json: Dùng để xử lý dữ liệu JSON (ví dụ: event[\"body\"]) import os: Dùng để đọc các Environment variables trong Configuration của Lambda dynamodb = boto3.resource('dynamodb'): Sử dụng giao diện “resource” (cấp cao, dễ dùng hơn) của boto3 cho DynamoDB cognito_client = boto3.client('cognito-idp'): Sử dụng giao diện “client” (cấp thấp, chi tiết hơn) cho Cognito Identity Provider TABLE_NAME = os.environ.get('TABLE_NAME'): Tên của bảng DynamoDB chứa thông tin người dùng USER_POOL_ID = os.environ.get('USER_POOL_ID'): ID của Cognito User Pool nơi người dùng được quản lý table = dynamodb.Table(TABLE_NAME): Tạo một đối tượng Table cụ thể từ dynamodb resource, trỏ đến bảng có tên là TABLE_NAME. Điều này giúp thực hiện các thao tác (như update_item) trực tiếp trên bảng đó build_update_params Function\rdef build_update_params(updates):: Khai báo tên hàm, tên tham số update_expression = \"SET \": Chuỗi lệnh SET cho DynamoDB (ví dụ: SET #name = :name, #email = :email) expression_names = {}: Một dictionary để map tên giữ chỗ (placeholder) với tên thuộc tính thật. Ví dụ: {\"#name\": \"name\"}. Điều này rất quan trọng để tránh lỗi với các từ khóa dự trữ (reserved words) của DynamoDB (như name) expression_values = {}: Một dictionary để map tên giữ chỗ với giá trị thật. Ví dụ: {\":name\": \"John Doe\"}. Điều này giúp ngăn ngừa lỗi SQL injection (mặc dù đây là NoSQL, nguyên tắc tương tự) attribute_map = { \"name\": \"#name\", \"email\": \"#email\", }\rĐịnh nghĩa một attribute_map. Nó chỉ định rằng nếu updates có chứa “name” hoặc “email”, chúng ta sẽ sử dụng tên giữ chỗ là #name và #email trong UpdateExpression for key, value in updates.items(): if key in attribute_map: placeholder = f\":{key}\" attr_name = attribute_map[key] update_expression += f\"{attr_name} = {placeholder}, \" expression_values[placeholder] = value expression_names[attr_name] = key\rfor key, value in updates.items():: Lặp qua từng cặp key (tên trường) và value (giá trị mới) trong dictionary updates mà người dùng gửi lên",
    "tags": [],
    "title": "Example with Dynamo and Cognito using Python",
    "uri": "/note/05_cloud/aws/lambda/01_example_with_dynamo_and_cognito/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control \u003e Gitlab",
    "content": "",
    "description": "",
    "tags": [],
    "title": "CI/CD Template",
    "uri": "/note/03_source-control/gitlab/02_ci-cd-template/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Operating System \u003e Linux",
    "content": "echo\rInput\necho \"Hello\"\rShow User and Group Information | whoami and id\rInput\nwhoami\rOutput\nyourusername\rInput\nid\rOutput\nuid=5000(labex) gid=5000(labex) groups=5000(labex),27(sudo),121(ssl-cert),5002(public)\ruid: Your User ID (a unique numerical identifier). gid: Your primary Group ID. groups: All the groups you are a member of. Input\nid root\rOutput\nuid=0(root) gid=0(root) groups=0(root)\rroot is the superuser – like the administrator of the system! Download the latest list of all available software and updates from the software servers | apt update\rsudo: Super User DO, do something with aministrator permission apt: Application Manager Tool on systems like Ubuntu update: Synchronize app packages on your computer with Internaet Repositpories Input\nsudo apt update\rInteractive process viewer for Unix systems | htop\rTo install\rhtop is like Task Manager on Windows Input\nsudo apt install htop\rTo run\rInput\nhtop\rDisplays current location in the file system | pwd\rpwd stands for “print working directory” Input\npwd\rDisplay relationship between the current directory and the home directory | echo ~\rInput\necho ~`\rShow contents of current directory | ls\rInput\nls\rShow contents of home directory | ls ~\rInput\nls ~\rGo to a folder | cd\rInput\ncd foldername\rGo to an above folder | cd ..\rInput\ncd ..\rGo to home directory | cd ~\rInput\ncd ~\rCreate an empty file | touch\rThe touch command is used to create an empty file. If the file already exists, it updates the file’s timestamp without changing its content. It’s a simple way to create new, empty files. Input\ntouch file1.txt\rWrite to a file | \u003e\r```echo`` is a command that prints text. The \u003e symbol redirects the output of echo into a file named file2.txt. If the file doesn’t exist, it’s created. If it does exist, its content is replaced. Input\necho \"Hello, Linux\" \u003e file2.txt\rCreate hidden file | .\rThis creates a hidden file. In Linux, any file or directory name that starts with a dot (.) is considered hidden. Input\necho \"Hidden file\" \u003e .hiddenfile\rCreate a directory | mkdir testdir\rThe mkdir command (short for “make directory”) creates a new directory named testdir Input\nmkdir testdir\rDetailed listing | ls -l\rInput\nls -l\rShow hidden files | ls -a\rInput\nls -a\rCombine options | ls -la\rThis combines the long format (-l) with showing all files (-a). Input\nls -la\rList contents of a specific directory | ls -l testdir\rThis lists the contents of the testdir directory Input\nls -l testdir",
    "description": "echo\rInput\necho \"Hello\"\rShow User and Group Information | whoami and id\rInput\nwhoami\rOutput\nyourusername\rInput\nid\rOutput\nuid=5000(labex) gid=5000(labex) groups=5000(labex),27(sudo),121(ssl-cert),5002(public)\ruid: Your User ID (a unique numerical identifier). gid: Your primary Group ID. groups: All the groups you are a member of. Input",
    "tags": [],
    "title": "Commands",
    "uri": "/note/02_operating-system/linux/commands/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control \u003e Gitlab \u003e CI/CD Template",
    "content": "Cloud and Virtual Machine\rAWS/CF-Provision-and-Deploy-EC2.gitlab-ci.yml\rDùng CloudFormation để tạo hạ tầng và deploy lên EC2 AWS/Deploy-EC2.gitlab-ci.yml\rDeploy một ứng dụng lên EC2 AWS/ECS.gitlab-ci.yml\rDeploy lên Dịch vụ AWS ECS Jobs/Deploy/ECS.gitlab-ci.yml\rMột template công việc (job) để deploy lên ECS, thường được dùng bởi Auto DevOps Jobs/Deploy.gitlab-ci.yml\rTemplate công việc deploy cơ bản GCP.gitlab-ci.yml\rTemplate chung cho Google Cloud Platform Heroku.gitlab-ci.yml\rDeploy lên Heroku Serverless.gitlab-ci.yml\rTemplate chung cho framework Serverless AWS/EKS.gitlab-ci.yml\rDeploy lên Amazon EKS - Kubernetes AWS/lambda-deploy.gitlab-ci.yml\rDeploy hàm AWS Lambda Container \u0026 Kubernetes\rOpenShift.gitlab-ci.yml\rDành cho việc triển khai lên nền tảng OpenShift Packer.gitlab-ci.yml\rDùng để build và đẩy (push) Docker image Infrastructure as Code (IaC) Deploying\rTerraform.gitlab-ci.yml\rTemplate chính cho Terraform để quản lý hạ tầng Terraform.latest.gitlab-ci.yml\rLuôn dùng phiên bản Terraform mới nhất Terraform.gitlab-ci.yml\rDùng để tạo các machine image PaaS Platform \u0026 Static Website\rPages/Auto-DevOps.gitlab-ci.yml\rDùng cho GitLab Pages Pages/Hugo.gitlab-ci.yml\rDùng cho trang tĩnh Hugo Pages/Jekyll.gitlab-ci.yml\rDùng cho trang tĩnh Jekyll Pages/HTML.gitlab-ci.yml\rTemplate cơ bản nhất, nó không “build” gì cả, chỉ đơn giản là lấy một thư mục (thường là public) chứa các tệp HTML/CSS/JS tĩnh của bạn và deploy chúng Pages/Gatsby.gitlab-ci.yml\rDùng cho Gatsby để build các trang web tĩnh hiệu suất cao bằng React và GraphQL Pages/Docusaurus.gitlab-ci.yml\rDùng để build và deploy các trang web làm bằng Docusaurus. Đây là SSG do Meta (Facebook) tạo ra, rất mạnh mẽ để xây dựng các trang tài liệu (documentation), đặc biệt là cho các dự án React Pages/Eleventy.gitlab-ci.yml\rDùng cho Eleventy (11ty). Đây là một SSG hiện đại, linh hoạt và rất nhẹ, không phụ thuộc vào một framework JavaScript cụ thể (như React hay Vue) Pages/GitBook.gitlab-ci.yml\rDùng cho GitBook, một công cụ chuyên dụng để xây dựng các cuốn sách trực tuyến, tài liệu kỹ thuật, hoặc cơ sở tri thức (knowledge base) đẹp mắt Pages/MkDocs.gitlab-ci.yml\rDùng cho MkDocs, một SSG viết bằng Python, được thiết kế đặc biệt để tạo các trang tài liệu (docs) từ các tệp Markdown một cách nhanh chóng và đơn giản. Pages/Pelican.gitlab-ci.yml\rDùng cho Pelican, một SSG khác cũng được viết bằng Python, thường được dùng để tạo blog và các trang web cá nhân. Pages/VuePress.gitlab-ci.yml\rDùng cho VuePress, một SSG được phát triển bởi nhóm Vue.js, tối ưu hóa cho việc viết tài liệu kỹ thuật, với các tính năng tích hợp sẵn cho việc này.",
    "description": "Cloud and Virtual Machine\rAWS/CF-Provision-and-Deploy-EC2.gitlab-ci.yml\rDùng CloudFormation để tạo hạ tầng và deploy lên EC2 AWS/Deploy-EC2.gitlab-ci.yml\rDeploy một ứng dụng lên EC2 AWS/ECS.gitlab-ci.yml\rDeploy lên Dịch vụ AWS ECS Jobs/Deploy/ECS.gitlab-ci.yml\rMột template công việc (job) để deploy lên ECS, thường được dùng bởi Auto DevOps Jobs/Deploy.gitlab-ci.yml\rTemplate công việc deploy cơ bản GCP.gitlab-ci.yml\rTemplate chung cho Google Cloud Platform Heroku.gitlab-ci.yml\rDeploy lên Heroku Serverless.gitlab-ci.yml\rTemplate chung cho framework Serverless AWS/EKS.gitlab-ci.yml\rDeploy lên Amazon EKS - Kubernetes AWS/lambda-deploy.gitlab-ci.yml\rDeploy hàm AWS Lambda Container \u0026 Kubernetes\rOpenShift.gitlab-ci.yml\rDành cho việc triển khai lên nền tảng OpenShift Packer.gitlab-ci.yml\rDùng để build và đẩy (push) Docker image Infrastructure as Code (IaC) Deploying\rTerraform.gitlab-ci.yml\rTemplate chính cho Terraform để quản lý hạ tầng Terraform.latest.gitlab-ci.yml\rLuôn dùng phiên bản Terraform mới nhất Terraform.gitlab-ci.yml\rDùng để tạo các machine image PaaS Platform \u0026 Static Website\rPages/Auto-DevOps.gitlab-ci.yml\rDùng cho GitLab Pages Pages/Hugo.gitlab-ci.yml\rDùng cho trang tĩnh Hugo Pages/Jekyll.gitlab-ci.yml\rDùng cho trang tĩnh Jekyll Pages/HTML.gitlab-ci.yml\rTemplate cơ bản nhất, nó không “build” gì cả, chỉ đơn giản là lấy một thư mục (thường là public) chứa các tệp HTML/CSS/JS tĩnh của bạn và deploy chúng Pages/Gatsby.gitlab-ci.yml\rDùng cho Gatsby để build các trang web tĩnh hiệu suất cao bằng React và GraphQL Pages/Docusaurus.gitlab-ci.yml\rDùng để build và deploy các trang web làm bằng Docusaurus. Đây là SSG do Meta (Facebook) tạo ra, rất mạnh mẽ để xây dựng các trang tài liệu (documentation), đặc biệt là cho các dự án React Pages/Eleventy.gitlab-ci.yml\rDùng cho Eleventy (11ty). Đây là một SSG hiện đại, linh hoạt và rất nhẹ, không phụ thuộc vào một framework JavaScript cụ thể (như React hay Vue) Pages/GitBook.gitlab-ci.yml\rDùng cho GitBook, một công cụ chuyên dụng để xây dựng các cuốn sách trực tuyến, tài liệu kỹ thuật, hoặc cơ sở tri thức (knowledge base) đẹp mắt Pages/MkDocs.gitlab-ci.yml\rDùng cho MkDocs, một SSG viết bằng Python, được thiết kế đặc biệt để tạo các trang tài liệu (docs) từ các tệp Markdown một cách nhanh chóng và đơn giản. Pages/Pelican.gitlab-ci.yml\rDùng cho Pelican, một SSG khác cũng được viết bằng Python, thường được dùng để tạo blog và các trang web cá nhân. Pages/VuePress.gitlab-ci.yml\rDùng cho VuePress, một SSG được phát triển bởi nhóm Vue.js, tối ưu hóa cho việc viết tài liệu kỹ thuật, với các tính năng tích hợp sẵn cho việc này.",
    "tags": [],
    "title": "Deployment Template",
    "uri": "/note/03_source-control/gitlab/02_ci-cd-template/b_deployment_template/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python \u003e Data Structures",
    "content": "Syntax\rInput\nmy_cat = {'size': 'fat', 'color': 'gray', 'age': 17} print(my_cat['size']) print('My cat has ' + my_cat['color'] + ' fur.')\rOutput\nfat\rMy cat has gray fur\rInput\nspam = {12345: 'Luggage Combination', 42: 'The Answer'} print(spam[12345]) print(spam[42]) print(spam[0])\rOutput\nLuggage Combination\rThe Answer\rTraceback (most recent call last):\rFile \"\u003cpython-input-0\u003e\", line 1, in \u003cmodule\u003e\rKeyError: 0\rReturning Values | values()\rInput\nspam = {'color': 'red', 'age': 42} for v in spam.values(): print(v)\rOutput\nred\r42\rReturning Keys | keys()\rInput\nspam = {'color': 'red', 'age': 42} for k in spam.keys(): print(k)\rOutput\ncolor\rage\rReturning Keys and Values | items()\rInput\nspam = {'color': 'red', 'age': 42} for i in spam.items(): print(i)\rOutput\n('color', 'red')\r('age', 42)\rChecking Whether a Key Exists | get()\rDictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key doesn’t exis Input\npicnic_items = {'apples': 5, 'cups': 2} print('I am bringing ' + str(picnic_items.get('cups', 0)) + ' cups.') print('I am bringing ' + str(picnic_items.get('eggs', 0)) + ' eggs.')\rOutput\nI am bringing 2 cups.\rI am bringing 0 eggs.\rSetting Default Values | setdefault()\rThe first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key doesn’t exist; if the key does exist, the setdefault() method returns the key’s value Input\nspam = {'name': 'Pooka', 'age': 5} print(spam.setdefault('color', 'black')) # Sets 'color' key to 'black' print(spam.setdefault('color', 'white')) # Does nothing\rOutput\nblack\rblack\rView object\rInput\nspam = {'color': 'red', 'age': 42} print(spam.keys()) print(list(spam.keys()))\rOutput\ndict_keys(['color', 'age'])\r['color', 'age']\rThe Multiple Assignment Trick\rInput\nspam = {'color': 'red', 'age': 42} for k, v in spam.items(): print('Key: ' + str(k) + ' Value: ' + str(v))\rOutput\nKey: color Value: red\rKey: age Value: 42",
    "description": "Syntax\rInput\nmy_cat = {'size': 'fat', 'color': 'gray', 'age': 17} print(my_cat['size']) print('My cat has ' + my_cat['color'] + ' fur.')\rOutput\nfat\rMy cat has gray fur\rInput\nspam = {12345: 'Luggage Combination', 42: 'The Answer'} print(spam[12345]) print(spam[42]) print(spam[0])\rOutput\nLuggage Combination\rThe Answer\rTraceback (most recent call last):\rFile \"\u003cpython-input-0\u003e\", line 1, in \u003cmodule\u003e\rKeyError: 0\rReturning Values | values()\rInput",
    "tags": [],
    "title": "Dictionary Data Type",
    "uri": "/note/01_programming-language/python/01_data-structures/b_dictionary_data_type/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control",
    "content": "Create Connection\rCI/CD Template",
    "description": "Create Connection\rCI/CD Template",
    "tags": [],
    "title": "Gitlab",
    "uri": "/note/03_source-control/gitlab/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note",
    "content": "Linux",
    "description": "Linux",
    "tags": [],
    "title": "Operating System",
    "uri": "/note/02_operating-system/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "Comparison Operator\rInput\n42 == 42\rOutput\nTrue\rInput\n42 == 42.0\rOutput\nTrue\rThe expression 42 == ‘42’ evaluates to False because Python considers the integer 42 to be different from the string ‘42’. However, Python does consider the integer 42 to be the same as the float 42.0. Input\n42 == '42'\rOutput\nFalse\rThe in and not in Operators\rInput\nprint('howdy' in ['hello', 'hi', 'howdy', 'heyas']) spam = ['hello', 'hi', 'howdy', 'heyas'] print('cat' in spam) print('howdy' not in spam) print('cat' not in spam)\rOutput\nTrue\rFalse\rFalse\rTrue",
    "description": "Comparison Operator\rInput\n42 == 42\rOutput\nTrue\rInput\n42 == 42.0\rOutput\nTrue\rThe expression 42 == ‘42’ evaluates to False because Python considers the integer 42 to be different from the string ‘42’. However, Python does consider the integer 42 to be the same as the float 42.0. Input\n42 == '42'\rOutput",
    "tags": [],
    "title": "Operators",
    "uri": "/note/01_programming-language/python/02_operators/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control \u003e Gitlab \u003e CI/CD Template",
    "content": "Static Application Security Testing (SAST)\rJobs/SAST.gitlab-ci.yml\rTemplate này thêm một job quét mã nguồn tĩnh Nó hoạt động như một người “soi” code tự động, đọc qua code (Java, Python, C#, Go…) ngay cả khi chúng chưa được build hay chạy Nó tìm kiếm các mẫu code “nguy hiểm” có thể dẫn đến lỗ hổng, như nguy cơ SQL Injection hoặc xử lý dữ liệu đầu vào (nguy cơ XSS) Dynamic Application Security Testing (DAST)\rJobs/DAST.gitlab-ci.yml\rTemplate này chạy một job “tấn công” ứng dụng web đang chạy Nó không đọc code. Thay vào đó, nó hoạt động như một hacker “mũ trắng” Sau khi đã build và deploy ứng dụng (ví dụ, deploy vào một “review environment”), job DAST sẽ cố gắng “tấn công” ứng dụng đó từ bên ngoài Nó gửi đi các payload độc hại để tìm các lỗ hổng mà chỉ có thể phát hiện được khi ứng dụng đang chạy (ví dụ: “Chuyện gì xảy ra nếu tôi nhập một đoạn script vào ô tìm kiếm?”) Infrastructure as Code (IaC) Scanning\rJobs/SAST-IaC.gitlab-ci.yml\rQuét các tệp cấu hình hạ tầng Thay vì quét code ứng dụng, nó quét các tệp định nghĩa hạ tầng như Terraform (.tf), AWS CloudFormation, hay Dockerfile Nó tìm các lỗi “cài đặt” bảo mật, ví dụ: “Bạn đã mở cổng 22 (SSH) cho toàn bộ internet” hoặc “Bạn đã tạo một S3 bucket cho phép truy cập công khai” Container Scanning\rJobs/Container-Scanning.gitlab-ci.yml\rQuét các ảnh (image) container (ví dụ: Docker image) Một Docker image được xây dựng từ nhiều “lớp” (layers), bao gồm một hệ điều hành cơ sở (như Ubuntu) và các thư viện khác Job này sẽ “mở” image của bạn ra và đối chiếu danh sách tất cả các phần mềm bên trong với một cơ sở dữ liệu về lỗ hổng đã biết (CVEs) Nó sẽ cảnh báo bạn nếu, ví dụ, “Image của bạn đang dùng một phiên bản OpenSSL đã lỗi thời và có lỗ hổng nghiêm trọng.” Secret Detection\rJobs/Secret-Detection.gitlab-ci.yml\rQuét code và lịch sử commit để tìm thông tin nhạy cảm (secrets) bị lộ Đây là một lỗi rất phổ biến. Lập trình viên đôi khi vô tình “commit” (đẩy) các thông tin nhạy cảm như API key, mật khẩu database, hoặc token truy cập vào Git Job này sẽ quét toàn bộ dự án của bạn (bao gồm cả lịch sử) để tìm các chuỗi văn bản trông giống như một “secret” và cảnh báo bạn ngay lập tức Dependency Scanning + License Scanning\rJobs/Dependency-Scanning.gitlab-ci.yml\rJobs/License-Scanning.gitlab-ci.yml\rQuét các thư viện bên ngoài (dependencies) mà dự án sử dụng\nDependency Scanning: $emsp; + Hầu hết các dự án đều dùng thư viện mã nguồn mở (ví dụ: từ npm, pip, maven). $emsp; + Job này kiểm tra các file quản lý thư viện (như package.json, requirements.txt) và báo cho bạn biết nếu bạn đang “dùng một thư viện X phiên bản 1.2, mà phiên bản đó vừa được phát hiện có lỗ hổng bảo mật.”\nLicense Scanning: $emsp; + Tương tự, job này kiểm tra “giấy phép” (license) của các thư viện đó để đảm bảo chúng tuân thủ chính sách của công ty bạn (ví dụ: “Dự án này cấm sử dụng các thư viện có giấy phép GPL”).\nWeb-API Fuzzing\rJobs/API-Fuzzing.gitlab-ci.yml\rThử nghiệm mờ\" (Fuzz testing) cho các API (Web-API) Job này tự động tạo ra hàng ngàn yêu cầu (request) “ngẫu nhiên” hoặc “dị dạng” và gửi chúng tới các điểm cuối (endpoint) API của bạn Mục đích là để xem API của bạn có bị “sập” (crash) hoặc rò rỉ thông tin khi nhận được dữ liệu không mong muốn hay không Coverage-Guided Fuzzing\rJobs/Coverage-Fuzzing.gitlab-ci.yml\rMột loại “thử nghiệm mờ” thông minh hơn, dùng cho các hàm (function) trong code Khác với API Fuzzing (hộp đen), loại này là “hộp trắng” Nó “biết” code của bạn. Nó gửi dữ liệu ngẫu nhiên vào một hàm cụ thể (ví dụ: một hàm xử lý ảnh trong C++) Sau đó, nó “quan sát” xem dữ liệu đó đã chạy qua những nhánh code nào (gọi là “coverage”). Dựa trên đó, nó “thông minh” tạo ra dữ liệu mới để cố gắng “chạm” tới những nhánh code chưa được kiểm tra, nhằm mục đích tìm ra các lỗi nghiêm trọng như tràn bộ đệm (buffer overflow). API Scanning\rJobs/DAST-API.gitlab-ci.yml\rMột biến thể của DAST được thiết kế dành riêng cho việc quét API (thay vì quét ứng dụng web đầy đủ).",
    "description": "Static Application Security Testing (SAST)\rJobs/SAST.gitlab-ci.yml\rTemplate này thêm một job quét mã nguồn tĩnh Nó hoạt động như một người “soi” code tự động, đọc qua code (Java, Python, C#, Go…) ngay cả khi chúng chưa được build hay chạy Nó tìm kiếm các mẫu code “nguy hiểm” có thể dẫn đến lỗ hổng, như nguy cơ SQL Injection hoặc xử lý dữ liệu đầu vào (nguy cơ XSS) Dynamic Application Security Testing (DAST)\rJobs/DAST.gitlab-ci.yml\rTemplate này chạy một job “tấn công” ứng dụng web đang chạy Nó không đọc code. Thay vào đó, nó hoạt động như một hacker “mũ trắng” Sau khi đã build và deploy ứng dụng (ví dụ, deploy vào một “review environment”), job DAST sẽ cố gắng “tấn công” ứng dụng đó từ bên ngoài Nó gửi đi các payload độc hại để tìm các lỗ hổng mà chỉ có thể phát hiện được khi ứng dụng đang chạy (ví dụ: “Chuyện gì xảy ra nếu tôi nhập một đoạn script vào ô tìm kiếm?”) Infrastructure as Code (IaC) Scanning\rJobs/SAST-IaC.gitlab-ci.yml\rQuét các tệp cấu hình hạ tầng Thay vì quét code ứng dụng, nó quét các tệp định nghĩa hạ tầng như Terraform (.tf), AWS CloudFormation, hay Dockerfile Nó tìm các lỗi “cài đặt” bảo mật, ví dụ: “Bạn đã mở cổng 22 (SSH) cho toàn bộ internet” hoặc “Bạn đã tạo một S3 bucket cho phép truy cập công khai” Container Scanning\rJobs/Container-Scanning.gitlab-ci.yml\rQuét các ảnh (image) container (ví dụ: Docker image) Một Docker image được xây dựng từ nhiều “lớp” (layers), bao gồm một hệ điều hành cơ sở (như Ubuntu) và các thư viện khác Job này sẽ “mở” image của bạn ra và đối chiếu danh sách tất cả các phần mềm bên trong với một cơ sở dữ liệu về lỗ hổng đã biết (CVEs) Nó sẽ cảnh báo bạn nếu, ví dụ, “Image của bạn đang dùng một phiên bản OpenSSL đã lỗi thời và có lỗ hổng nghiêm trọng.” Secret Detection\rJobs/Secret-Detection.gitlab-ci.yml\rQuét code và lịch sử commit để tìm thông tin nhạy cảm (secrets) bị lộ Đây là một lỗi rất phổ biến. Lập trình viên đôi khi vô tình “commit” (đẩy) các thông tin nhạy cảm như API key, mật khẩu database, hoặc token truy cập vào Git Job này sẽ quét toàn bộ dự án của bạn (bao gồm cả lịch sử) để tìm các chuỗi văn bản trông giống như một “secret” và cảnh báo bạn ngay lập tức Dependency Scanning + License Scanning\rJobs/Dependency-Scanning.gitlab-ci.yml\rJobs/License-Scanning.gitlab-ci.yml\rQuét các thư viện bên ngoài (dependencies) mà dự án sử dụng",
    "tags": [],
    "title": "Security Template",
    "uri": "/note/03_source-control/gitlab/02_ci-cd-template/c_security_template/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note",
    "content": "GitHub\rGitlab",
    "description": "GitHub\rGitlab",
    "tags": [],
    "title": "Source Control",
    "uri": "/note/03_source-control/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "The global Statement\rIf you need to modify a global variable from within a function, use the global statement. Including a line such as global eggs at the top of a function tells Python, “In this function, eggs refers to the global variable, so don’t create a local variable with this name. Input\ndef spam(): global eggs eggs = 'spam' eggs = 'global' spam() print(eggs)\rOutput\nspam",
    "description": "The global Statement\rIf you need to modify a global variable from within a function, use the global statement. Including a line such as global eggs at the top of a function tells Python, “In this function, eggs refers to the global variable, so don’t create a local variable with this name. Input\ndef spam(): global eggs eggs = 'spam' eggs = 'global' spam() print(eggs)\rOutput",
    "tags": [],
    "title": "Statements",
    "uri": "/note/01_programming-language/python/03_statements/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python \u003e Data Structures",
    "content": "String is like a list of characters, so is inherits list attributes Escape Characters | \\\rInput\nprint('Say hi to Bob\\'s mother.')\rOutput\nSay hi to Bob's mother.\rRaw Strings | r\rInput\nprint(r'The file is in C:\\Users\\Alice\\Desktop')\rOutput\nThe file is in C:\\Users\\Alice\\Desktop\rMultiline Strings | ''' '''\rInput\nprint('''Dear Alice, Can you feed Eve's cat this weekend? Sincerely, Bob''')\rOutput\nDear Alice,\rCan you feed Eve's cat this weekend?\rSincerely,\rBob\rMultiline Comments | \"\"\"\" \"\"\"\"\rInput\n\"\"\"This is a test Python program. Written by Al Sweigart al@inventwithpython.com This program was designed for Python 3, not Python 2. \"\"\" def say_hello(): \"\"\"This function prints hello. It does not return anything.\"\"\" print('Hello!')\rF-Strings | f\rInput\nname = 'Al' age = 4000 print(f'My name is {name}. I am {age} years old.') print(f'In ten years I will be {age + 10}')\rOutput\nMy name is Al. I am 4000 years old.\rIn ten years I will be 4010\rF-String Alternatives | %s and format()\rInput\nname = 'Al' age = 4000 print('My name is %s. I am %s years old.' % (name, age)) print('In ten years I will be %s' % (age + 10))\rOutput\nMy name is Al. I am 4000 years old.\rIn ten years I will be 4010\rInput\nname = 'Al' age = 4000 print('My name is {}. I am {} years old.'.format(name, age))\rOutput\nMy name is Al. I am 4000 years old.\rYou can put the index integer (starting at 0) inside the curly brackets to note which of the arguments to format() should be inserted Input\nname = 'Al' age = 4000 print('{1} years ago, {0} was born and named {0}.'.format(name, age))\rOutput\n4000 years ago, Al was born and named Al.\rChanging the Case | upper() and lower()\rInput\nspam = 'Hello, world!' spam = spam.upper() print(spam) spam = spam.lower() print(spam)\rOutput\nHELLO, WORLD!\rhello, world!\rChecking the Case | isupper() and ```islower()``\rInput\nspam = 'Hello, world!' print(spam.islower()) print(spam.isupper()) print('HELLO'.isupper()) print('abc12345'.islower()) print('12345'.islower()) print('12345'.isupper())\rOutput\nFalse\rFalse\rTrue\rTrue\rFalse\rFalse\rChecking String Characteristics | isalpha(), isalnum(), isdecimal(), isspace() and istitle()\rInput\nprint('hello'.isalpha()) print('hello123'.isalpha()) print('hello123'.isalnum()) print('hello'.isalnum()) print('123'.isdecimal()) print(' '.isspace()) print('This Is Title Case'.istitle())\rOutput\nTrue\rFalse\rTrue\rTrue\rTrue\rTrue\rTrue\rChecking the Start or End of a String | startswith() and endswith()\rInput\nprint('Hello, world!'.startswith('Hello')) print('Hello, world!'.endswith('world!')) print('abc123'.startswith('abcdef')) print('abc123'.endswith('12')) print('Hello, world!'.startswith('Hello, world!')) print('Hello, world!'.endswith('Hello, world!'))\rOutput\nTrue\rTrue\rFalse\rFalse\rTrue\rTrue\rJoining Strings | join()\rInput\nprint(', '.join(['cats', 'rats', 'bats']))\rOutput\ncats, rats, bats\rSplitting Strings | split()\rInput\nprint('My name is Simon'.split()) print('My name is Simon'.split('m'))\rOutput\n['My', 'name', 'is', 'Simon']\r['My na', 'e is Si', 'on']\rJustifying Text | rjust and ljust\rInput\nprint('Hello'.rjust(10)) print('Hello'.rjust(20)) print('Hello, World'.rjust(20)) print('Hello'.ljust(10)) Output\nHello\rHello\rHello, World\rHello Input\nprint('Hello'.rjust(20, '*')) print('Hello'.ljust(20, '-'))\rOutput\n***************Hello\rHello--------------- Centering Text | center()\rInput\nprint('Hello'.center(20)) print('Hello'.center(20, '='))\rOutput\nHello =======Hello======== Removing Whitespace | strip(), lstrip() and rstrip()\rInput\nspam = ' Hello, World ' print(spam.strip()) print(spam.lstrip()) print(spam.rstrip()) spam = 'SpamSpamBaconSpamEggsSpamSpam' # A string argument will specify which characters on the ends to strip print(spam.strip('ampS')) print(spam.strip('Spam')) Output\nHello, World\rHello, World Hello, World\rBaconSpamEggs\rBaconSpamEggs\rNumeric Code Points of Characters | ord() and chr()\rInput\nprint(ord('A')) print(ord('4')) print(ord('!')) print(chr(65)) print(ord('A') \u003c ord('B')) print(chr(ord('A') + 1))\rOutput\n65\r52\r33\rA\rTrue\rB",
    "description": "String is like a list of characters, so is inherits list attributes Escape Characters | \\\rInput\nprint('Say hi to Bob\\'s mother.')\rOutput\nSay hi to Bob's mother.\rRaw Strings | r\rInput\nprint(r'The file is in C:\\Users\\Alice\\Desktop')\rOutput",
    "tags": [],
    "title": "String Data Type",
    "uri": "/note/01_programming-language/python/01_data-structures/c_string_data_type/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Operating System \u003e Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Ubuntu",
    "uri": "/note/02_operating-system/linux/ubuntu/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "The round() Function\rFor halfway numbers that end with .5, the number is rounded to the nearest even integer. This is called banker’s rounding. Input\nround(3.5)\rOutput\n4\rInput\nround(2.5)\rOutput\n2\rThe bool() Function\rWhen used in conditions, 0, 0.0, and ’’ (the empty string) are considered False, while all other values are considered True. The print() Function\rInput\ndef greet(name=\"Guest\"): print(f'Hello, {name}!') greet() greet(\"Bob\")\rOutput\nHello, Guest!\rHello, Bob!\rNamed Parameters\rInput\nprint('Hello') print('World')\rOutput\nHello\rWorld\rInput\nprint('Hello', end='') print('World')\rOutput\nHelloWorld\rInput\nprint('cats', 'dogs', 'mice')\rOutput\ncats dogs mice\rInput\nprint('cats', 'dogs', 'mice', sep=',')\rOutput\ncats,dogs,mice\rThe Multiple Assignment Trick\rInput\ndef get_person_information(): name = 'Alice' age = 30 city = 'New York' return name, age, city name, age, city = get_person_information() print(f'Name: {name}, Age: {age}, City: {city}')\rOutput\nName: Alice, Age: 30, City: New York\rAnonymous Function\rInput\ndouble = lambda x: x * 2 print(double(5))\rOutput\n10\rInput\ndata = [(1,5), (3,2), (2,7)] sorted_data = sorted(data, key = lambda x: x[1]) # Sort by second value in tuples print(sorted_data)\rOutput\n[(3, 2), (1, 5), (2, 7)]\rInput\nnumbers = [1, 2, 3, 4, 5, 6] even_number = list(filter(lambda x: x % 2 == 0, numbers)) print(even_number)\rOutput\n[2, 4, 6]\rGenerator and yield\rInput\ndef simple_generator(): yield 1 yield 2 yield 3 gen = simple_generator() for value in gen: print(value)\rOutput\n1\r2\r3\rFunction and class decorators\rInput\nimport time def timing_decorator(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(f\"Function {func.__name__} executed in {end_time - start_time:.4f}s\") return result return wrapper @timing_decorator def slow_function(): time.sleep(2) return \"Function complete\" print(slow_function())\rInput\ndef add_method_decorator(cls): def new_method(self): return \"This is a new method\" cls.new_method = new_method return cls @add_method_decorator class MyClass: def existing_method(self): return \"This is an existing method\" obj = MyClass() print(obj.existing_method()) print(obj.new_method())\rContext manager\rNhững hàm có dạng __name__ được gọi là Phương thức Dunder (Dunder Methods) hoặc Phương thức Ma thuật (Magic Methods). “Dunder” là viết tắt của “Double Underscore” (hai dấu gạch dưới).\nĐây là một phương thức đặc biệt mà Python sẽ tự động gọi trong một hoàn cảnh cụ thể. Bạn (lập trình viên) không nên gọi trực tiếp các hàm này.\nVí dụ đơn giản:\nKhi bạn viết a + b, Python sẽ bí mật gọi a.add(b). Khi bạn viết len(my_list), Python sẽ bí mật gọi my_list.len(). Khi bạn viết with … as f:, Python sẽ bí mật gọi f.enter(). Khi bạn viết obj = MyClass(), Python sẽ bí mật gọi obj.init() (sau khi đã gọi new). Input\nclass MyContextManager: def __enter__(self): print(\"Entering the context\") return self def __exit__(self, exc_type, exc_val, exc_tb): print(\"Existing the context\") def do_something(self): print(\"Doing something\") with MyContextManager() as manager: manager.do_something()",
    "description": "The round() Function\rFor halfway numbers that end with .5, the number is rounded to the nearest even integer. This is called banker’s rounding. Input\nround(3.5)\rOutput\n4\rInput\nround(2.5)\rOutput\n2\rThe bool() Function\rWhen used in conditions, 0, 0.0, and ’’ (the empty string) are considered False, while all other values are considered True. The print() Function\rInput",
    "tags": [],
    "title": "Functions",
    "uri": "/note/01_programming-language/python/04_functions/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Source Control \u003e Gitlab \u003e CI/CD Template",
    "content": "Other Template\rJobs/Code-Quality.gitlab-ci.yml\rQuét code để tìm các vấn đề về “chất lượng” (độ phức tạp, code trùng lặp, lỗi cú pháp) thay vì lỗ hổng bảo mật Jobs/Browser-Performance.gitlab-ci.yml\rKiểm tra hiệu suất (tốc độ tải) của trang web sau khi deploy",
    "description": "Other Template\rJobs/Code-Quality.gitlab-ci.yml\rQuét code để tìm các vấn đề về “chất lượng” (độ phức tạp, code trùng lặp, lỗi cú pháp) thay vì lỗ hổng bảo mật Jobs/Browser-Performance.gitlab-ci.yml\rKiểm tra hiệu suất (tốc độ tải) của trang web sau khi deploy",
    "tags": [],
    "title": "Other Template",
    "uri": "/note/03_source-control/gitlab/02_ci-cd-template/d_other_template/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python \u003e Data Structures",
    "content": "Syntax\rInput\na, b, c = (10, 20, 30) print(a) print(b) print(c)\rOutput\n10\r20\r30\rMultiple data type values\rInput\nmixed_tuple = (1, 'hello' , 3.14) print(mixed_tuple) print(type(mixed_tuple[0])) print(type(mixed_tuple[1])) print(type(mixed_tuple[2]))\rOutput\n(1, 'hello', 3.14)\r\u003cclass 'int'\u003e\r\u003cclass 'str'\u003e\r\u003cclass 'float'\u003e\rInput\neggs = ('hello', 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs))\rOutput\nhello\r(42, 0.5)\r3\rImmutable\rInput\neggs = ('hello', 42, 0.5) eggs[1] = 99 Output\nFile \"\u003cpython-input-0\u003e\", line 1, in \u003cmodule\u003e\reggs[1] = 99\rTypeError: 'tuple' object does not support item assignment",
    "description": "Syntax\rInput\na, b, c = (10, 20, 30) print(a) print(b) print(c)\rOutput\n10\r20\r30\rMultiple data type values\rInput\nmixed_tuple = (1, 'hello' , 3.14) print(mixed_tuple) print(type(mixed_tuple[0])) print(type(mixed_tuple[1])) print(type(mixed_tuple[2]))\rOutput\n(1, 'hello', 3.14)\r\u003cclass 'int'\u003e\r\u003cclass 'str'\u003e\r\u003cclass 'float'\u003e\rInput",
    "tags": [],
    "title": "Tuple Data Type",
    "uri": "/note/01_programming-language/python/01_data-structures/d_tuple_data_type/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note",
    "content": "Virtual Box",
    "description": "Virtual Box",
    "tags": [],
    "title": "Virtual Machine",
    "uri": "/note/04_virtual-machine/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note",
    "content": "AWS",
    "description": "AWS",
    "tags": [],
    "title": "Cloud",
    "uri": "/note/05_cloud/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "*args\rĐây là một hàm đơn giản, nhận vào hai tham số và trả về tổng của chúng: Input\ndef foo(x, y): return x + y print(foo(1, 2))\rOutput\n3\rBây giờ, vấn đề của chúng ta là cần tính tổng của tất cả các số được truyền vào hàm, nhưng không biết trước số lượng của chúng. Đây là lúc là cú pháp *args cực kỳ hữu ích, bởi nó cũng giúp chúng ta có thể truyền một số lượng tham số tuỳ ý vào hàm. Input\ndef foo(*args): result = 0 for x in args: result += x return result print(foo(1, 2)) print(foo(1, 2, 3))\rOutput\n3 6\rVề lý thuyết, chúng ta có thể đặt *args ở bất cứ đâu chúng ta muốn trong định nghĩa hàm. Tuy nhiên, nếu đặt ở giữa, chúng ta sẽ không thể gọi hàm được bởi mọi lời gọi sẽ đều gặp lỗi. Nguyên nhân là do *args sẽ nhận toàn bộ các tham số “còn lại” sau khi các tham số đầu tiên đã có giá trị, do đó, các tham số phía sau *args sẽ không bao giờ được truyền vào nữa. **kwargs\rCách sử dụng **kwargs cũng tương tự như như *args, tuy nhiên, nó không dùng cho các tham số thông thường truyền vào lần lượt, mà nó được sử dụng cho các tham số đặt tên (thuật ngữ chính xác là named arguments hoặc keyword arguments). def foo(a=0, b=1): return a + b print(foo()) print(foo(1, 2)) print(foo(b=3, a=4))\rOutput\n1\r3\r7\rInput\ndef foo(**kwargs): for key, value in kwargs.items(): print(key, value) print(foo(a=1, b=2))\rOutput\na 1\rb 2\rLưu ý rằng, với cách sử dụng **kwargs thì kwargs trong hàm sẽ nhận giá trị là một dict với key là các tham số được truyền kèm giá trị tương ứng của chúng. Notice for *args and ```**kwargs``\rThứ tự khi khai báo các tham số này rất quan trọng và không thể thay đổi được. Thứ tự đúng sẽ là: Các tham số bình thường *args **kwargs Upack with * and **\rWhen calling function\rCú pháp * và ** khi gọi hàm sẽ yêu cầu unpack giá trị được truyền vào trước khi thực hiện hàm đó. Và khi unpack, hàm sẽ nhận các tham số đơn lẻ như các tham số riêng biệt vậy.\nChúng ta có thể sử dụng unpack để truyền tham số vào cho hàm. Nói một cách đơn giản thì cú pháp * được xử dụng với một đối tượng iterable, còn ** chỉ có thể dùng được với dict mà thôi.\nInput\ndef foo(**kargs): for data in kargs.items(): print(data, end='') print() x = (1, 2, 3) y = {'a': 7, 'b': 8, 'c': 9} print(x) print(*x) foo(**y)\rOutput\n(1, 2, 3)\r1 2 3\r('a', 7)('b', 8)('c', 9)\rWhen define variables\rMột nhu cầu khá thường xuyên của lập trình viên đó là chia giá trị một list (hoặc tuple) vào các biến riêng biệt. Input\nx = [1, 2, 3, 4, 5, 6] a, *b, c = x print(a) print(b) print(c)\rOutput\n1\r[2, 3, 4, 5]\r6\rMột vấn đề nho nhỏ là cú pháp ** không áp dụng được khi gán biến để unpack một dict được. Other cases\rMột điều thú vị là unpack có thể áp dụng với mọi đối tượng iterable, nó sẽ rất cần thiết nếu chúng ta cần làm “phẳng” 2 hay nhiều list. list1 = [1, 2, 3] list2 = [4, 5] list3 = [6, 7, 8, 9] print([*list1, *list2, *list3])\rOutput\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\rInput\ndict1 = {\"A\": 1, \"B\": 2} dict2 = {\"C\": 3, \"D\": 4} print({**dict1, **dict2})\rOutput\n{'A': 1, 'B': 2, 'C': 3, 'D': 4}",
    "description": "*args\rĐây là một hàm đơn giản, nhận vào hai tham số và trả về tổng của chúng: Input\ndef foo(x, y): return x + y print(foo(1, 2))\rOutput\n3\rBây giờ, vấn đề của chúng ta là cần tính tổng của tất cả các số được truyền vào hàm, nhưng không biết trước số lượng của chúng. Đây là lúc là cú pháp *args cực kỳ hữu ích, bởi nó cũng giúp chúng ta có thể truyền một số lượng tham số tuỳ ý vào hàm. Input",
    "tags": [],
    "title": "Parameters",
    "uri": "/note/01_programming-language/python/05_parameters/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python \u003e Data Structures",
    "content": "Syntax\rInput\nmy_set = {1, 2, 3} print(my_set)\rOutput\n{1, 2, 3}\rAdd Values | add()\rData in set cannot be duplicated Input\nmy_set = {1, 2, 3} my_set.add(4) my_set.add(2) print(my_set)\rOutput\n{1, 2, 3, 4}\rRemove Values | remove()\rData in set cannot be duplicated Input\nmy_set = {1, 2, 3, 4} my_set.remove(4) print(my_set) try: my_set.remove(5) except KeyError as e: print('Error: ', e) print(my_set)\rOutput\n{1, 2, 3}\r{1, 2, 3}\rDiscard Values | discard()\rInput\nmy_set = {1, 2, 3, 4} my_set.discard(4) print(my_set) my_set.discard(5) print(my_set)\rOutput\n{1, 2, 3}\r{1, 2, 3}\rSet Union | union()\rInput\nset1 = {1, 2, 3} set2 = {4, 5, 6} union_set = set1.union(set2) print(union_set)\rOutput\n{1, 2, 3, 4, 5, 6}\rSet Intersection | intersection()\rInput\nset1 = {1, 2, 3} set2 = {3, 4, 5} intersection_set = set1.intersection(set2) print(intersection_set)\rOutput\n{3}",
    "description": "Syntax\rInput\nmy_set = {1, 2, 3} print(my_set)\rOutput\n{1, 2, 3}\rAdd Values | add()\rData in set cannot be duplicated Input\nmy_set = {1, 2, 3} my_set.add(4) my_set.add(2) print(my_set)\rOutput\n{1, 2, 3, 4}\rRemove Values | remove()\rData in set cannot be duplicated Input",
    "tags": [],
    "title": "Set Data Type",
    "uri": "/note/01_programming-language/python/01_data-structures/e_set_data_type/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "Syntax\rInput\nclass Car: def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.is_running = False def start(self): self.is_running = True print(\"Car started.\") def drive(self): if self.is_running: print(\"Car is moving.\") else: print(\"Car is not started yet.\") my_car = Car(\"Toyota\", \"Corolla\", 2022) print('My car: ', my_car.make, my_car.model, my_car.year) my_car.start() my_car.drive()\rOutput\nMy car: Toyota Corolla 2022\rCar started.\rCar is moving.\rInheritance\rInput\nclass Animal: def speak(self): print(\"Animal speaks\") class Dog(Animal): def bark(self): print(\"Dog barks\") def wag_tail(self): print(\"Dog wags tail\") dog = Dog() dog.speak() dog.bark()\rOutput\nAnimal speaks\rDog barks",
    "description": "Syntax\rInput\nclass Car: def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.is_running = False def start(self): self.is_running = True print(\"Car started.\") def drive(self): if self.is_running: print(\"Car is moving.\") else: print(\"Car is not started yet.\") my_car = Car(\"Toyota\", \"Corolla\", 2022) print('My car: ', my_car.make, my_car.model, my_car.year) my_car.start() my_car.drive()\rOutput\nMy car: Toyota Corolla 2022\rCar started.\rCar is moving.\rInheritance\rInput",
    "tags": [],
    "title": "Classes",
    "uri": "/note/01_programming-language/python/06_classes/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python \u003e Data Structures",
    "content": "List and Tuple Type Conversion\rInput\nprint(tuple(['cat', 'dog', 5])) print(list(('cat', 'dog', 5))) print(list('hello'))\rOutput\n('cat', 'dog', 5)\r['cat', 'dog', 5]\r['h', 'e', 'l', 'l', 'o']\rComparing Dictionarie and List\rInput\nspam = ['cats', 'dogs', 'moose'] bacon = ['dogs', 'moose', 'cats'] print(spam == bacon) # The order of list items matters\rOuput\nFalse\rInput\neggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'} ham = {'species': ' t', 'age': '8', 'name': 'Zophie'} print(eggs == ham) The order of dictionary key-value pairs doesn't matter\rOutput\nTrue",
    "description": "List and Tuple Type Conversion\rInput\nprint(tuple(['cat', 'dog', 5])) print(list(('cat', 'dog', 5))) print(list('hello'))\rOutput\n('cat', 'dog', 5)\r['cat', 'dog', 5]\r['h', 'e', 'l', 'l', 'o']\rComparing Dictionarie and List\rInput\nspam = ['cats', 'dogs', 'moose'] bacon = ['dogs', 'moose', 'cats'] print(spam == bacon) # The order of list items matters\rOuput",
    "tags": [],
    "title": "Data Type Comparision",
    "uri": "/note/01_programming-language/python/01_data-structures/f_data_type_comparision/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "Read and write\rInput\nwith open('example.txt', 'w') as file: file.write('Hello, world!\\n') file.write('This is a test file\\n') with open('example.txt', 'r') as file: content = file.read() print(content) with open('example.txt', 'a') as file: file.write('\\nAppending a new line.') with open('example.txt', 'r') as file: for line in file: print(line, end='')\rOutput\nHello, world!\rThis is a test file\rHello, world!\rThis is a test file\rAppending a new line.\rRead line\rInput\nwith open('example.txt', 'w') as file: file.write('Line 1\\nLine 2\\nLine 3') with open('example.txt', 'r') as file: content = file.read() print(content) with open('example.txt', 'r') as file: line1 = file.readline() line2 = file.readline() print('\\n', line1, line2)\rOutput\nLine 1\rLine 2\rLine 3\rLine 1\rLine 2\rWrite lines\rInput\nwith open('example.txt', 'w') as file: file.write('Single line using write()\\n') lines = ['line 1\\n', 'line 2\\n', 'line 3\\n'] with open('example.txt', 'w') as file: file.writelines(lines) with open('example.txt', 'r') as file: content = file.read() print(\"Using writelines():\\n\", content)\rOutput\nUsing writelines():\rline 1\rline 2\rline 3",
    "description": "Read and write\rInput\nwith open('example.txt', 'w') as file: file.write('Hello, world!\\n') file.write('This is a test file\\n') with open('example.txt', 'r') as file: content = file.read() print(content) with open('example.txt', 'a') as file: file.write('\\nAppending a new line.') with open('example.txt', 'r') as file: for line in file: print(line, end='')\rOutput\nHello, world!\rThis is a test file\rHello, world!\rThis is a test file\rAppending a new line.\rRead line\rInput",
    "tags": [],
    "title": "Files",
    "uri": "/note/01_programming-language/python/07_files/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note",
    "content": "Install guide\rGo to this website https://config.office.com/deploymentsettings For Office Suites, choose Office LTSC Standard 20XX - Volume License Check Apps you want to install Click Next Select primary language Click Next twice For Upgrade options, turn off Uninstall any MSI versions of Office, including Visio and Project Click Next three times Click Finish Click Export Choose Office Open XML Formats Click OK Check I accept the terms in the license agreement Click Export Go to this website https://www.microsoft.com/en-us/download/details.aspx?id=49117 Download Office Deployment Tool Copy two downloaded files to a new folder name office in disk C Open CMD as administrator Run this command cd c:\\office Then run this setup.exe /configure configuration.xml",
    "description": "Install guide\rGo to this website https://config.office.com/deploymentsettings For Office Suites, choose Office LTSC Standard 20XX - Volume License Check Apps you want to install Click Next Select primary language Click Next twice For Upgrade options, turn off Uninstall any MSI versions of Office, including Visio and Project Click Next three times Click Finish Click Export Choose Office Open XML Formats Click OK Check I accept the terms in the license agreement Click Export Go to this website https://www.microsoft.com/en-us/download/details.aspx?id=49117 Download Office Deployment Tool Copy two downloaded files to a new folder name office in disk C Open CMD as administrator Run this command cd c:\\office Then run this setup.exe /configure configuration.xml",
    "tags": [],
    "title": "Office",
    "uri": "/note/06_office/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "Install libraries on Mu editor\rEnsure you are in the Python 3 mode in the Mu editor. The current mode is displayed in the bottom right corner of the window. Click the Admin or cog icon (gear icon) in the bottom right corner of the Mu editor. In the window that appears, select the Third Party Packages tab. Type name of the libraries into the text box. You can install multiple packages by placing each on a new line. Click OK. math\rInput\nimport math result = math.sqrt(16) print(result)\rOutput\n4.0\rInput\nfrom math import pi, cos result = cos(pi) print(result)\rOutput\n-1.0\rnumpy\rInput\nimport numpy as np array1 = np.array([1, 2, 3, 4, 5]) array2 = np.array([[1, 2, 3], [4, 5, 6]]) array3 = np.array([1, 2, 3]) array4 = np.array([4, 5, 6]) addition = array3 + array4 multiplication = array3 * array4 print(array1) print(array2) print(addition) print(multiplication)\rOutput\n[1 2 3 4 5]\r[[1 2 3]\r[4 5 6]]\r[5 7 9]\r[ 4 10 18]\rdatetime\rInput\nimport datetime now = datetime.datetime.today() print(now)\rOutput\n2025-11-04 20:03:37.981197\rrandom\rInput\nimport random rand_int = random.randint(1, 10) rand_float = random.random() print(rand_int) print(rand_float)\rOutput\n6\r0.8069049490320905\ros\rInput\nimport os files = os.listdir('.') print(files)\rOutput\n['chapter6_coinFlipStreaks.py', 'chapter6_commaCode.py', 'collatz.py', 'dishonestcapacity.py', 'exitExample.py', 'exm.py', 'hello.py', 'isValidChesSBoard.py', 'matrixscreensaver.py', 'printTable.py', 'rpsGame.py', 'rpsGame_myVersion.py', 'yourName.py', 'zigzag.py']\rjson\rInput\nimport json data = {'name': 'Alice', 'age': 28, 'city': 'New York'} json_str = json.dumps(data) data_back = json.loads(json_str) print(json_str) print(data_back)\rOutput\n{\"name\": \"Alice\", \"age\": 28, \"city\": \"New York\"}\r{'name': 'Alice', 'age': 28, 'city': 'New York'}\rpandas\rpandas là một thư viện Python cực kỳ mạnh mẽ và phổ biến, chuyên dùng để phân tích và xử lý dữ liệu (đặc biệt là dữ liệu dạng bảng) Input\nimport pandas as pd data = {'Name': ['Alice', 'Bob', 'Charlie', 'Devid'], 'Age': [25, 30, 35, 40], 'City': ['New York', 'Los Angles', 'Chicago', 'Houston']} df = pd.DataFrame(data) print(\"DataFrame:\") print(df) print(\"\\nAccessing a Column:\") print(df['Name']) print(\"\\nAccessing a Row:\") print(df.iloc[0]) print(\"\\nApplying a function:\") df['Age'] = df['Age'].apply(lambda x: x + 5) print(df)\rOutput\nDataFrame:\rName Age City\r0 Alice 25 New York\r1 Bob 30 Los Angles\r2 Charlie 35 Chicago\r3 Devid 40 Houston\rAccessing a Column\r0 Alice\r1 Bob\r2 Charlie\r3 Devid\rName: Name, dtype: object\rAccessing a Row:\rName Alice\rAge 25\rCity New York\rName: 0, dtype: object\rApplying a function:\rName Age City\r0 Alice 30 New York\r1 Bob 35 Los Angles\r2 Charlie 40 Chicago\r3 Devid 45 Houston\rmatplotlib\rInput\nimport matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] plt.plot(x, y) plt.xlabel('X-axis') plt.ylabel('Y-axis') plt.title('line plot') plt.show()\rInput\nimport matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y = [2, 4, 6, 8, 10] plt.scatter(x, y, color='red', marker='o') plt.xlabel('X-axis') plt.ylabel('Y-axis') plt.title('Scatter plot') plt.show()\rpyperclip\rInput\nimport pyperclip pyperclip.copy('Hello, world!') print(pyperclip.paste())\rResult:\nHello, world!\rInput\nimport pyperclip print(pyperclip.paste())\rFor example, if I copied this sentence to the clipboard and then called paste(), it would look like this:\rOutput\nFor example, if I copied this sentence to the clipboard and then called paste(), it would look like this:\rrandom\rInput\nimport random pets = ['Dog', 'Cat', 'Moose'] print(random.choice(pets))\rInput\nimport random people = ['Alice', 'Bob', 'Carol', 'David'] random.shuffle(people) print(people)\rcopy\rIf the list you need to copy contains lists, use the copy.deepcopy() function instead of copy.copy(). The copy.deepcopy() function will copy these inner lists as well. Input\nimport copy spam = ['A', 'B', 'C'] cheese = copy.copy(spam) # Creates a duplicate copy of the list cheese[1] = 42 # Changes cheese print(spam ) # The spam variable is unchanged print(cheese) # The cheese variable is changed\rOutput\n['A', 'B', 'C']\r['A', 42, 'C']",
    "description": "Install libraries on Mu editor\rEnsure you are in the Python 3 mode in the Mu editor. The current mode is displayed in the bottom right corner of the window. Click the Admin or cog icon (gear icon) in the bottom right corner of the Mu editor. In the window that appears, select the Third Party Packages tab. Type name of the libraries into the text box. You can install multiple packages by placing each on a new line. Click OK. math\rInput",
    "tags": [],
    "title": "Libraries",
    "uri": "/note/01_programming-language/python/08_libraries/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "Exception Handling\rInput\ndef spam(divide_by): try: return 42 / divide_by except ZeroDivisionError: print('Error: Invalid argument.') print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))\rOutput\n21.0\r3.5\rError: Invalid argument.\rNone\r42.0\rInput\ndef spam(divide_by): return 42 / divide_by try: print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) except ZeroDivisionError: print('Error: Invalid argument.')\rOutput\n21.0\r3.5\rError: Invalid argument.\rRaising Exceptions\rInput\nraise Exception('This is the error message.')\rOutput\nTraceback (most recent call last):\rFile \"\u003cpyshell#191\u003e\", line 1, in \u003cmodule\u003e\rraise Exception('This is the error message.')\rException: This is the error message.\rInput\ndef box_print(symbol, width, height): if len(symbol) != 1: raise Exception('Symbol must be a single character string.') if width \u003c= 2: raise Exception('Width must be greater than 2.') if height \u003c= 2: raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) try: box_print('*', 4, 4) box_print('O', 20, 5) box_print('x', 1, 3) box_print('ZZ', 3, 3) except Exception as err: print('An exception happened: ' + str(err)) try: box_print('ZZ', 3, 3) except Exception as err: print('An exception happened: ' + str(err))\rOutput\n****\r* *\r* *\r****\rOOOOOOOOOOOOOOOOOOOO\rO O\rO O\rO O\rOOOOOOOOOOOOOOOOOOOO\rAn exception happened: Width must be greater than 2.\rAn exception happened: Symbol must be a single character string.\rAssertions\rInput\nages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] ages.sort() assert ages[0] \u003c= ages[-1] # Assert that the first age is \u003c= the last age\rOutput\nInput\nages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] ages.reverse() assert ages[0] \u003c= ages[-1] # Assert that the first age is \u003c= the last age\rOutput\nTraceback (most recent call last):\rFile \"\u003cpython-input-0\u003e\", line 1, in \u003cmodule\u003e\rAssertionError\rThe logging Module\rInput\nimport logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') logging.debug('Start of program') def factorial(n): logging.debug('Start of factorial(' + str(n) + ')') total = 1 for i in range(n + 1): total *= i logging.debug('i is ' + str(i) + ', total is ' + str(total)) logging.debug('End of factorial(' + str(n) + ')') return total print(factorial(5)) logging.debug('End of program')\rOutput\n2025-11-02 22:53:01,430 - DEBUG - Start of program\r2025-11-02 22:53:01,430 - DEBUG - Start of factorial(5)\r2025-11-02 22:53:01,430 - DEBUG - i is 0, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 1, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 2, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 3, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 4, total is 0\r2025-11-02 22:53:01,430 - DEBUG - i is 5, total is 0\r2025-11-02 22:53:01,430 - DEBUG - End of factorial(5)\r0\r2025-11-02 22:53:01,430 - DEBUG - End of program\rLogfiles\rInput\nimport logging logging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')\rLogging Levels\rLevel Logging function Description DEBUG logging.debug() The lowest level, used for small details. Usually, you’ll care about these messages only when diagnosing problems. INFO logging.info() Used to record information about general events in your program or to confirm that it’s working at various points. WARNING logging.warning() Used to indicate a potential problem that doesn’t prevent the program from working but might do so in the future. ERROR logging.error() Used to record an error that caused the program to fail to do something. CRITICAL logging.critical() The highest level, used to indicate a fatal error that has caused, or is about to cause, the program to stop running entirely. Passing logging.DEBUG to the basicConfig() function’s level named parameter will show messages from all the logging levels (DEBUG being the lowest level). But after developing your program some more, you may be interested only in errors. In that case, you can set basicConfig()’s level argument to logging.ERROR. This will show only ERROR and CRITICAL messages and will skip the DEBUG, INFO, and WARNING messages. Disabled Logging\rInput\nimport logging logging.basicConfig(level=logging.INFO, format=' %(asctime)s - %(levelname)s - %(message)s') logging.critical('Critical error! Critical error!') logging.disable(logging.CRITICAL) logging.critical('Critical error! Critical error!') logging.error('Error! Error!')\rOutput\n2025-11-02 22:39:52,251 - CRITICAL - Critical error! Critical error!\rInput\nimport logging logging.basicConfig(level=logging.INFO, format=' %(asctime)s - %(levelname)s - %(message)s') logging.critical('Critical error! Critical error!') logging.disable(logging.ERROR) logging.critical('Critical error! Critical error!') logging.error('Error! Error!')\rOutput\n2025-11-02 22:41:46,767 - CRITICAL - Critical error! Critical error!\r2025-11-02 22:41:46,767 - CRITICAL - Critical error! Critical error!\rFinally\rInput\ntry: result = 20 / 2 except ZeroDivisionError: print(\"error: division by zero is not allowed.\") else: print(\"Division successful, result is : \", result) finally: print(\"This block always executes\")\rOutput\nDivision successful, result is : 10.0\rThis block always executes",
    "description": "Exception Handling\rInput\ndef spam(divide_by): try: return 42 / divide_by except ZeroDivisionError: print('Error: Invalid argument.') print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))\rOutput\n21.0\r3.5\rError: Invalid argument.\rNone\r42.0\rInput\ndef spam(divide_by): return 42 / divide_by try: print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) except ZeroDivisionError: print('Error: Invalid argument.')\rOutput\n21.0\r3.5\rError: Invalid argument.\rRaising Exceptions\rInput",
    "tags": [],
    "title": "Debugging",
    "uri": "/note/01_programming-language/python/10_debugging/index.html"
  },
  {
    "breadcrumb": "Home Page",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Home Page \u003e Programming Note \u003e Programming Language \u003e Python",
    "content": "Finding Text Patterns with Regular Expressions\rInput\nimport re phone_num_pattern_obj = re.compile(r'\\d{3}-\\d{3}-\\d{4}') match_obj = phone_num_pattern_obj.search('My number is 415-555-4242.') print(match_obj.group())\rOutput\n415-555-4242\rGrouping with Parentheses\rInput\nimport re phone_re = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)') mo = phone_re.search('My number is 415-555-4242.') print(mo.group(1)) print(mo.group(2)) print(mo.group(0)) print(mo.group()) print(mo.groups()) area_code, main_number = mo.groups() print(area_code) print(main_number)\rOutput\n415\r555-4242\r415-555-4242\r415-555-4242\r('415', '555-4242')\r415\r555-4242\rUsing Escape Characters\rInput\nimport re pattern = re.compile(r'(\\(\\d\\d\\d\\)) (\\d\\d\\d-\\d\\d\\d\\d)')\\ mo = pattern.search('My phone number is (415) 555-4242.') print(mo.group(1)) print(mo.group(2))\rOutput\n(415)\r555-4242\rMatching Characters from Alternate Groups | |\rInput\nimport re pattern = re.compile(r'Cat(erpillar|astrophe|ch|egory)') match = pattern.search('Catch me if you can.') print(match.group()) print(match.group(1))\rOutput\nCatch\rch\rReturning All Matches | findall()\rInput\nimport re pattern = re.compile(r'\\d{3}-\\d{3}-\\d{4}') # This regex has no groups print(pattern.findall('Cell: 415-555-9999 Work: 212-555-0000'))\rOutput\n['415-555-9999', '212-555-0000']\rInput\nimport re pattern = re.compile(r'(\\d{3})-(\\d{3})-(\\d{4})') # This regex has groups. print(pattern.findall('Cell: 415-555-9999 Work: 212-555-0000'))\rOutput\n[('415', '555', '9999'), ('212', '555', '0000')]\rInput\nimport re pattern = re.compile(r'\\d{3}') print(pattern.findall('1234')) print(pattern.findall('12345')) print(pattern.findall('123456')) print(pattern.findall('1234567'))\rOutput\n['123']\r['123']\r['123', '456']\r['123', '456']\rUsing Character Classes and Negative Character Classes\rInput\nimport re vowel_pattern = re.compile(r'[aeiouAEIOU]') print(vowel_pattern.findall('RoboCop eats BABY FOOD.'))\rOutput\n['o', 'o', 'o', 'e', 'a', 'A', 'O', 'O']\rInput\nimport re consonant_pattern = re.compile(r'[^aeiouAEIOU]') # By placing a caret character (^) just after the character class’s opening bracket, you can make a negative character class print(consonant_pattern.findall('RoboCop eats BABY FOOD.'))\rOutput\n['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']\rUsing Shorthand Character Classes\rShorthand character class Represents … \\d Any numeric digit from 0 to 9. \\D Any character that is not a numeric digit from 0 to 9. \\w Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters.) \\W Any character that is not a letter, numeric digit, or the underscore character. \\s Any space, tab, or newline character. (Think of this as matching “space” characters.) \\S Any character that is not a space, tab, or newline character. Input\nimport re pattern = re.compile(r'\\d+\\s\\w+') # The regular expression \\d+\\s\\w+ will match text that has one or more numeric digits (\\d+), followed by a whitespace character (\\s), followed by one or more letter/digit/underscore characters (\\w+) print(pattern.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge'))\rOutput\n['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']\rMatching Everything with the Dot Character | .\rInput\nimport re at_re = re.compile(r'.at') print(at_re.findall('The cat in the hat sat on the flat mat.'))\rOutput\n['cat', 'hat', 'sat', 'lat', 'mat']\rBeing Careful What You Match For\rThe best and worst thing about regular expressions is that they will match exactly what you ask for. Here are some common points of confusion regarding character classes: The [A-Z] or [a-z] character class matches uppercase or lowercase letters, respectively, but not both. You need to use [A-Za-z] to match both cases. + The [A-Za-z] character class matches only plain, unaccented letters. For example, the regex string r’First Name: ([A-Za-z]+)’ would match “First Name: ” followed by a group of one or more unaccented letters. But singer Sinéad O’Connor’s first name would match up to the é only, and the group would be set to ‘Sin’. + The \\w character class matches all letters, including accented letters and characters from other alphabets. But it also matches numbers and the underscore character, so the regex string r’First Name: (\\w+)’ may match more than you intended. + The \\w character class matches all letters, but the regex string r’Last Name: (\\w+)’ would capture Sinéad O’Connor’s last name only up until the apostrophe character. This means the group would capture her last name as ‘O’. + Straight and smart quote characters (’ \" ‘ ’ “ ”) are considered completely different from each other and must be specified separately. Matching an Optional Pattern | ?\rInput\nimport re # The ? part of the regular expression means that the pattern is optional pattern = re.compile(r'42?!') print(pattern.search('42!')) print(pattern.search('4!')) print(pattern.search('42') == None) # No match\rOutput\n\u003cre.Match object; span=(0, 3), match='42!'\u003e\r\u003cre.Match object; span=(0, 2), match='4!'\u003e\rTrue\rInput\nimport re pattern = re.compile(r'(\\d{3}-)?\\d{3}-\\d{4}') match1 = pattern.search('My number is 415-555-4242') print(match1.group()) match2 = pattern.search('My number is 555-4242') print(match2.group()) Output\n415-555-4242\r555-4242\rMatching Zero or More Qualifiers | *\rInput\nimport re pattern = re.compile('Eggs( and spam)*') print(pattern.search('Eggs')) print(pattern.search('Eggs and spam')) print(pattern.search('Eggs and spam and spam')) print(pattern.search('Eggs and spam and spam and spam'))\rOutput\n\u003cre.Match object; span=(0, 4), match='Eggs'\u003e\r\u003cre.Match object; span=(0, 13), match='Eggs and spam'\u003e\r\u003cre.Match object; span=(0, 22), match='Eggs and spam and spam'\u003e\r\u003cre.Match object; span=(0, 31), match='Eggs and spam and spam and spam'\u003e\rMatching One or More Qualifiers | +\rInput\nimport re pattern = re.compile('Eggs( and spam)+') print(pattern.search('Eggs and spam')) print(pattern.search('Eggs and spam and spam')) print(pattern.search('Eggs and spam and spam and spam'))\rOutput\n\u003cre.Match object; span=(0, 4), match='Eggs'\u003e\r\u003cre.Match object; span=(0, 13), match='Eggs and spam'\u003e\r\u003cre.Match object; span=(0, 22), match='Eggs and spam and spam'\u003e\r\u003cre.Match object; span=(0, 31), match='Eggs and spam and spam and spam'\u003e\rMatching a Specific Number of Qualifiers\rInput\nimport re haRegex = re.compile(r'(Ha){3}') match1 = haRegex.search('HaHaHa') print(match1.group()) match = haRegex.search('HaHa') print(match == None)\rOutput\nHaHaHa\rTrue\rGreedy and Non-greedy Matching | ?, * and +\rThe ? quantifier is the same as {0,1}. The * quantifier is the same as {0,}. The + quantifier is the same as {1,}. Input\nimport re greedy_pattern = re.compile(r'(Ha){3,5}') match1 = greedy_pattern.search('HaHaHaHaHa') print(match1.group()) lazy_pattern = re.compile(r'(Ha){3,5}?') match2 = lazy_pattern.search('HaHaHaHaHa') print(match2.group())\rOutput\nHaHaHaHaHa\rHaHaHa\rMatching Everything | .* and .*?\rInput\nimport re name_pattern = re.compile(r'First Name: (.*) Last Name: (.*)') name_match = name_pattern.search('First Name: Al Last Name: Sweigart') print(name_match.group(1)) print(name_match.group(2))\rOutput\nAl\rSweigart\rThe dot-star uses greedy mode: it will always try to match as much text as possible. To match any and all text in a non-greedy or lazy fashion, use the dot, star, and question mark (.*?). As when it’s used with curly brackets, the question mark tells Python to match in a non-greedy way. Input\nimport re lazy_pattern = re.compile(r'\u003c.*?\u003e') match1 = lazy_pattern.search('\u003cTo serve man\u003e for dinner.\u003e') print(match1.group()) greedy_re = re.compile(r'\u003c.*\u003e') match2 = greedy_re.search('\u003cTo serve man\u003e for dinner.\u003e') print(match2.group())\rOutput\nAl\rSweigart\rMatching Newline Characters | re.DOTALL\rInput\nimport re no_newline_re = re.compile('.*') print(no_newline_re.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group()) print() newline_re = re.compile('.*', re.DOTALL) print(newline_re.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group())\rOutput\nServe the public trust.\rServe the public trust.\rProtect the innocent. Uphold the law.\rMatching at the Start and End of a String | ^, $ and /b\rInput\nimport re begins_with_hello = re.compile(r'^Hello') print(begins_with_hello.search('Hello, world!')) print(begins_with_hello.search('He said \"Hello.\"') == None)\rOutput\n\u003cre.Match object; span=(0, 5), match='Hello'\u003e\rTrue\rInput\nimport re ends_with_number = re.compile(r'\\d$') print(ends_with_number.search('Your number is 42')) print(ends_with_number.search('Your number is forty two.') == None)\rOutput\n\u003cre.Match object; span=(16, 17), match='2'\u003e\rTrue\rInput\nimport re whole_string_is_num = re.compile(r'^\\d+$') print(whole_string_is_num.search('1234567890')) print(whole_string_is_num.search('12345xyz67890') == None)\rOutput\n\u003cre.Match object; span=(0, 10), match='1234567890'\u003e\rTrue\rInput\nimport re pattern = re.compile(r'\\bcat.*?\\b') print(pattern.findall('The cat found a catapult catalog in the catacombs.')) print() pattern = re.compile(r'\\Bcat\\B') print(pattern.findall('certificate')) # Match print(pattern.findall('catastrophe')) # No match\rOutput\n['cat', 'catapult', 'catalog', 'catacombs']\r['cat']\r[]\rCase-Insensitive Matching | re.I\rInput\nimport re pattern = re.compile(r'robocop', re.I) print(pattern.search('RoboCop is part man, part machine, all cop.').group()) print(pattern.search('ROBOCOP protects the innocent.').group()) print(pattern.search('Have you seen robocop?').group())\rOutput\nRoboCop\rROBOCOP\rrobocop\rSubstituting Strings | sub()\rInput\nimport re pattern = re.compile(r'robocop', re.I) agent_pattern = re.compile(r'Agent \\w+') print(agent_pattern.sub('CENSORED', 'Agent Alice contacted Agent Bob.'))\rOutput\nCENSORED contacted CENSORED.\rInput\nimport re agent_pattern = re.compile(r'Agent (\\w)\\w*') print(agent_pattern.sub(r'\\1****', 'Agent Alice contacted Agent Bob.'))\rOutput\nA**** contacted B****.\rManaging Complex Regexes with Verbose Mode | re.VERBOSE\rInput\npattern = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))? # Area code (\\s|-|\\.)? # Separator \\d{3} # First three digits (\\s|-|\\.) # Separator \\d{4} # Last four digits (\\s*(ext|x|ext\\.)\\s*\\d{2,5})? # Extension )''', re.VERBOSE)",
    "description": "Finding Text Patterns with Regular Expressions\rInput\nimport re phone_num_pattern_obj = re.compile(r'\\d{3}-\\d{3}-\\d{4}') match_obj = phone_num_pattern_obj.search('My number is 415-555-4242.') print(match_obj.group())\rOutput\n415-555-4242\rGrouping with Parentheses\rInput\nimport re phone_re = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)') mo = phone_re.search('My number is 415-555-4242.') print(mo.group(1)) print(mo.group(2)) print(mo.group(0)) print(mo.group()) print(mo.groups()) area_code, main_number = mo.groups() print(area_code) print(main_number)\rOutput",
    "tags": [],
    "title": "Regular Expressions",
    "uri": "/note/01_programming-language/python/09_regular-expressions/index.html"
  },
  {
    "breadcrumb": "Home Page",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
