[{"id":0,"href":"/docs/1-note/1-python/","title":"1. Python","section":"Note","content":"\u0026ldquo;round()\u0026rdquo; function#\rround(3.5)Result: 4\nround(2.5)Result: 2\n\u0026ldquo;For halfway numbers that end with .5, the number is rounded to the nearest even integer. This is called banker’s rounding.\u0026rdquo;\n- Automate the Boring Stuff with Python by Al Swigart, [Chapter 1](https://automatetheboringstuff.com/3e/chapter1.html) - Python Basics - Value comparision#\r42 == 42Result: True\n42 == 42.0Result: True\n42 == \u0026#39;42\u0026#39;Result: False\n\u0026quot; The expression 42 == \u0026lsquo;42\u0026rsquo; evaluates to False because Python considers the integer 42 to be different from the string \u0026lsquo;42\u0026rsquo;. However, Python does consider the integer 42 to be the same as the float 42.0.\u0026quot;\n- Automate the Boring Stuff with Python by Al Swigart, [Chapter 2 - if-else and Flow Control](https://automatetheboringstuff.com/3e/chapter2.html) - \u0026ldquo;bool()\u0026rdquo; function#\rWhen used in conditions, 0, 0.0, and \u0026rsquo;\u0026rsquo; (the empty string) are considered False, while all other values are considered True.\n- Automate the Boring Stuff with Python by Al Swigart, [Chapter 3 - Loops](https://automatetheboringstuff.com/3e/chapter3.html) - \u0026ldquo;None\u0026rdquo; value#\rIn Python, a value called None represents the absence of a value. The None value is the only value of the NoneType data type. (Other programming languages might call this value null, nil, or undefined). Just like the Boolean True and False values, you must always write None with a capital N.\nThis value-without-a-value can be helpful when you need to store something that shouldn’t be confused for a real value in a variable. One place where None is used is as the return value of print(). The print() function displays text on the screen, and doesn’t need to return anything in the same way len() or input() does. But since all function calls need to evaluate to a return value, print() returns None. To see this in action, enter the following into the interactive shell:\nspam = print(\u0026#39;Hello!\u0026#39;)Result: Hello!\nNone == spamResult: True\nBehind the scenes, Python adds return None to the end of any function definition with no return statement. This behavior resembles the way in which a while or for loop implicitly ends with a continue statement. Functions also return None if you use a return statement without a value (that is, just the return keyword by itself).\n- Automate the Boring Stuff with Python by Al Swigart, [Chapter 4 - Functions](https://automatetheboringstuff.com/3e/chapter4.html) - Named Parameters#\rOn the other hand, Python identifies named parameters by the name placed before them in the function call. You’ll also hear named parameters called keyword parameters or keyword arguments, though they have nothing to do with Python keywords. Programmers often use named parameters to provide optional arguments. For example, the print() function uses the optional parameters end and sep to specify separator characters to print at the end of its arguments and between its arguments, respectively.\nprint(\u0026#39;Hello\u0026#39;) print(\u0026#39;World\u0026#39;)Result:\nHello\rWorldprint(\u0026#39;Hello\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;World\u0026#39;)Result: HelloWorld\nprint(\u0026#39;cats\u0026#39;, \u0026#39;dogs\u0026#39;, \u0026#39;mice\u0026#39;)Result: cats dogs mice\nprint(\u0026#39;cats\u0026#39;, \u0026#39;dogs\u0026#39;, \u0026#39;mice\u0026#39;, sep=\u0026#39;,\u0026#39;)Result: cats,dogs,mice\n- Automate the Boring Stuff with Python by Al Swigart, [Chapter 4 - Functions](https://automatetheboringstuff.com/3e/chapter4.html) - \u0026ldquo;global\u0026rdquo; Statement#\rIf you need to modify a global variable from within a function, use the global statement. Including a line such as global eggs at the top of a function tells Python, “In this function, eggs refers to the global variable, so don’t create a local variable with this name.\ndef spam(): global eggs eggs = \u0026#39;spam\u0026#39; eggs = \u0026#39;global\u0026#39; spam() print(eggs)Result: spam\n- Automate the Boring Stuff with Python by Al Swigart, [Chapter 4 - Functions](https://automatetheboringstuff.com/3e/chapter4.html) -\rException Handling#\rMost of the time, exceptions indicate a bug in your code that you need to fix. But sometimes exceptions can be expected and recovered from. For example, in Chapter 10 you’ll learn how to read text from files. If you specify a filename for a file that doesn’t exist, Python raises a FileNotFoundError exception. You might want to handle this exception by asking the user to enter the filename again rather than having this unhandled exception immediately crash your program.\nErrors can be handled with try and except statements. The code that could potentially have an error is put in a try clause. The program execution moves to the start of a following except clause if an error happens.\ndef spam(divide_by): try: # Any code in this block that causes ZeroDivisionError won\u0026#39;t crash the program: return 42 / divide_by except ZeroDivisionError: # If ZeroDivisionError happened, the code in this block runs: print(\u0026#39;Error: Invalid argument.\u0026#39;) print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))Result\n21.0\r3.5\rError: Invalid argument.\rNone\r42.0def spam(divide_by): return 42 / divide_by try: print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) except ZeroDivisionError: print(\u0026#39;Error: Invalid argument.\u0026#39;)Result:\n21.0\r3.5\rError: Invalid argument.The reason print(spam(1)) is never executed is because once the execution jumps to the code in the except clause, it does not return to the try clause. Instead, it just continues moving down the program as normal.\n- Automate the Boring Stuff with Python by Al Swigart, Chapter 4 - Formatted string literal#\r# Let\u0026#39;s assume the variable \u0026#39;age\u0026#39; has a value age = 30 # This is the f-string: message = f\u0026#39;I am {age} years old.\u0026#39; print(message)Result: I am 30 years old.\nWhen you put an f or F just before the opening quotation mark of a string, you are telling Python to treat it as an f-string. This allows you to place variables and even simple Python code directly inside the string by enclosing them in curly braces {}. Python will evaluate the code inside the braces and insert the result into the string.\nRaising Exceptions#\rPython raises an exception whenever it tries to execute invalid code. But you can also raise your own exceptions in your code. Raising an exception is a way of saying, “Stop running this code, and move the program execution to the except statement.” We raise exceptions with a raise statement, which consists of the following:\nThe raise keyword A call to the Exception() function A string with a helpful error message passed to the Exception() function raise Exception(\u0026#39;This is the error message.\u0026#39;)Result:\nTraceback (most recent call last):\rFile \u0026#34;\u0026lt;pyshell#191\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\rraise Exception(\u0026#39;This is the error message.\u0026#39;)\rException: This is the error message.If no try and except statements cover the raise statement that raised the exception, the program simply crashes and displays the exception’s error message. Often, it’s the code that calls the function containing a raise statement, rather than the function itself, that knows how to handle an exception. That means you’ll commonly see a raise statement inside a function, and the try and except statements in the code calling the function.\ndef box_print(symbol, width, height): if len(symbol) != 1: raise Exception(\u0026#39;Symbol must be a single character string.\u0026#39;) if width \u0026lt;= 2: raise Exception(\u0026#39;Width must be greater than 2.\u0026#39;) if height \u0026lt;= 2: raise Exception(\u0026#39;Height must be greater than 2.\u0026#39;) print(symbol * width) for i in range(height - 2): print(symbol + (\u0026#39; \u0026#39; * (width - 2)) + symbol) print(symbol * width) try: box_print(\u0026#39;*\u0026#39;, 4, 4) box_print(\u0026#39;O\u0026#39;, 20, 5) box_print(\u0026#39;x\u0026#39;, 1, 3) box_print(\u0026#39;ZZ\u0026#39;, 3, 3) except Exception as err: print(\u0026#39;An exception happened: \u0026#39; + str(err)) try: box_print(\u0026#39;ZZ\u0026#39;, 3, 3) except Exception as err: print(\u0026#39;An exception happened: \u0026#39; + str(err))Result:\n****\r* *\r* *\r****\rOOOOOOOOOOOOOOOOOOOO\rO O\rO O\rO O\rOOOOOOOOOOOOOOOOOOOO\rAn exception happened: Width must be greater than 2.\rAn exception happened: Symbol must be a single character string. - Automate the Boring Stuff with Python by Al Swigart, [Chapter 5 - Debugging](https://automatetheboringstuff.com/3e/chapter5.html) - "}]